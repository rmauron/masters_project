---
title: "ArchR analysis with multiomics data"
author: "RaphaÃ«l Mauron"
format: 
  html:
    code-fold: true
    toc: true
    number-sections: true
    theme: spacelab
    embed-resources: true
---

# Pipeline for multiomics analysis
snATAC-seq and snRNA-seq from the same cells are available.
The cells are not labeled.


## Links
Mainly from: https://github.com/GreenleafLab/ArchR_Website/blob/ui_updates/bookdown/21_MultiomicDataAnalysis.Rmd
and: https://www.archrproject.com/bookdown/getting-started-with-archr.html


## Importing data and setting up a Multiome project


loading ArchR, setting up our genome (`hg38`, `mm10`, ...), threads (which are system dependent so you should change that based on your computational resources), and our random seed (produce same set of random numbers).

```{r}
#| message: false
#| warning: false
#| output: false

library(ArchR)
library(tidyverse)

#addArchRGenome("hg38") #for human
addArchRGenome("mm10") #for mouse
library(BSgenome.Mmusculus.UCSC.mm10)
addArchRThreads(32) #rocommended 1/2 of total available cores
set.seed(1)
#projMulti1 <- loadArchRProject(path = "./Save-ProjMulti1", force = FALSE, showLogo = F)
```


```{r}
#when working on server/cluters, need to set the working directory aka the path to your input files:
#setwd("/Users/raphael.mauron/archr/archr_multiome/multiome_data")


#Get Input Fragment Files. Here, input the ATAC-seq data.
#if multiple files (from experiments, samples, ...) insert as a vector c("sample1", "sample2", "sample3")
inputFiles <- getInputFiles(c("/Users/raphaelmauron/archr_rr3/data-raw/ATAC/CF1",
                              "/Users/raphaelmauron/archr_rr3/data-raw/ATAC/CF2",
                              "/Users/raphaelmauron/archr_rr3/data-raw/ATAC/CF7",
                              "/Users/raphaelmauron/archr_rr3/data-raw/ATAC/CG8",
                              "/Users/raphaelmauron/archr_rr3/data-raw/ATAC/CG9"))


#insert corresponding name c("name1", "name2", "name3")
names(inputFiles) <- c("CF1",
                       "CF2",
                       "CF7",
                       "CG8",
                       "CG9")
```


If we inspect `inputFiles` you can see that we have a `.fragments.tsv.gz` file for each sample. 
These files are outputs of the 10x Genomics `cellranger-arc` pipeline.

```{r}
#check the inputs
inputFiles
```


## Create Arrow Files & Project

create ArrowFiles from the scATAC-seq fragment files

```{r}
#| message: false
#| warning: false
#| output: false

ArrowFiles <- createArrowFiles(
  inputFiles = inputFiles, #contains only the ATAC data for now
  sampleNames = names(inputFiles), #names(atacFiles) #if you use mock dataset
  minTSS = 4,
  minFrags = 1000,
  addTileMat = TRUE,
  addGeneScoreMat = TRUE
)
```


Note: At this stage, in the working directory figures a repository containing quality control plot for each sample passed.
./QualityControl/ --> QC plots


create an `ArchRProject` object from those ArrowFiles

```{r}
#| message: false
#| warning: false
#| output: false

projMulti1 <- ArchRProject(ArrowFiles = ArrowFiles)
```


## Importing snRNA-seq

`import10xFeatureMatrix()` function which integrate the `filtered_feature_bc_matrix.h5` files

`filtered_feature_bc_matrix.h5` created by `cellranger-arc` are not always perfectly matched across samples
ArchR throws an error if your various scRNA-seq input files do not match based on the gene names or the metadata columns because we view this as an unforseen incompatibility between data, potentially caused by alignment to different reference genomes or something similar. 

We provide two options which are controlled by the `strictMatch` parameter. 

- `strictMatch = FALSE` which will coerce all samples to match the metadata information of the first sample from your `input`. 
- `strictMatch = TRUE` which will remove the offending genes from all samples.

```{r}
#| message: false
#| warning: false
#| output: false

#create an ArchR object containing the RNA data.

#setwd("/Users/raphael.mauron/archr/archr_multiome/multiome_data") #path to data when working on server.

seRNA <- import10xFeatureMatrix(
  input = c("/Users/raphaelmauron/archr_rr3/data-raw/ATAC/CF1/filtered_feature_bc_matrix.h5",
            "/Users/raphaelmauron/archr_rr3/data-raw/ATAC/CF2/filtered_feature_bc_matrix.h5",
            "/Users/raphaelmauron/archr_rr3/data-raw/ATAC/CF7/filtered_feature_bc_matrix.h5",
            "/Users/raphaelmauron/archr_rr3/data-raw/ATAC/CG8/filtered_feature_bc_matrix.h5",
            "/Users/raphaelmauron/archr_rr3/data-raw/ATAC/CG9/filtered_feature_bc_matrix.h5"),
  
  names = c("CF1",
            "CF2",
            "CF7",
            "CG8",
            "CG9"),
  
  strictMatch = TRUE
)
```


### QC

```{r}
#Count per condition
condition_sample <- table(projMulti1@cellColData$Sample)
condition_sample <- as.data.frame(condition_sample)
condition_sample <- cbind(condition_sample, before_filter = c("before", "before", "before", "before", "before"))
condition_sample <- setnames(condition_sample, c("Sample", "nCells", "filter"))
condition_sample
```


```{r}
p_sample <- ggplot(condition_sample,
       aes(x = Sample, y = nCells)) +
    geom_bar(stat = "identity")+
    ggtitle("Number of cells per sample")
#p_sample
```


```{r}
cat("Total number of cells among the samples before doublets removal is:", nCells(projMulti1))
```


```{r}
p_frags <- plotGroups(
    projMulti1,
    groupBy = "Sample",
    colorBy = "cellColData",
    name = "nFrags",
    plotAs = "violin",
    alpha = 0.4,
    addBoxPlot = T,
    log = F
)
#p_frags

p_TSS <- plotGroups(
    projMulti1,
    groupBy = "Sample",
    colorBy = "cellColData",
    name = "TSSEnrichment",
    plotAs = "violin",
    alpha = 0.4,
    addBoxPlot = T
)
#p_TSS

p_multi_frags <- plotGroups(
    projMulti1,
    groupBy = "Sample",
    colorBy = "cellColData",
    name = "nMultiFrags",
    plotAs = "violin",
    alpha = 0.4,
    addBoxPlot = T
)
#p_multi_frags
```


```{r}
#save plot
plotPDF(p_frags, p_TSS, p_multi_frags, name = "QC-sample", addDOC = FALSE)
rm(p_frags, p_multi_frags, p_TSS)
```

## Create subgroups by condition


```{r}
#adding conditions Flight vs Ground as a CellColData
projMulti1 <- addCellColData(ArchRProj = projMulti1, data = paste0(gsub("0|1|2|3|4|5|6|7|8|9","", projMulti1@cellColData$Sample)), name = "Conditions", cells = getCellNames(projMulti1), force = TRUE)
```


```{r}
#Have to know how to "group" the samples. Here, we want to remove the numbers after CF1,2,7 or CG8,9 
# bioNames <- gsub("0|1|2|3|4|5|6|7|8|9","", projMulti1$Sample)
# unique(bioNames)
# projMulti1$Conditions <- bioNames
```


```{r}
p_frags <- plotGroups(
    projMulti1,
    groupBy = "Conditions",
    colorBy = "cellColData",
    name = "nFrags",
    plotAs = "violin",
    alpha = 0.4,
    addBoxPlot = T,
    log = F
)
#p_frags
```


```{r}
#Count per condition
condition_table <- table(projMulti1@cellColData$Conditions)
condition_table <- as.data.frame(condition_table)
condition_table <- setnames(condition_table, c("Condition", "nCells"))
condition_table
```

```{r}
p_cond <- ggplot(condition_table,                                 
       aes(x = Condition,
           y = nCells)) + 
  geom_bar(stat = "identity")+
  ggtitle("Number of cells per condition")
#p_cond
```


```{r}
#save plot
plotPDF(p_sample, p_frags, p_cond, name = "QC-condition-sample", addDOC = FALSE)
rm(p_sample, p_frags, p_cond)
```


```{r}
#| message: false
#| warning: false
#| output: false

#save project since we will change project now
saveArchRProject(ArchRProj = projMulti1, outputDirectory = "Save-ProjMulti1", load = F)
```


```{r}
#load the project from last saved project (if necessary)
#library(ArchR)
#projMulti1 <- loadArchRProject(path = "./Save-ProjMulti1", force = FALSE, showLogo = F)
```


check to see how many cells in our project (the ones that have passed scATAC-seq quality control) are not also in our scRNA-seq data

```{r}
length(which(getCellNames(projMulti1) %ni% colnames(seRNA)))
```


remove these cells from our project. We do this using the `subsetArchRProject()` function and saving this as a new `ArchRProject` called `projMulti2`.

```{r}
#| message: false
#| warning: false
#| output: false

cellsToKeep <- which(getCellNames(projMulti1) %in% colnames(seRNA))
projMulti2 <- subsetArchRProject(
    ArchRProj = projMulti1, 
    cells = getCellNames(projMulti1)[cellsToKeep], 
    outputDirectory = "Save-ProjMulti2", 
    force = TRUE)
```

The next thing that we want to do is add this scRNA-seq data to our `ArchRProject` via the `addGeneExpressionMatrix()` function. 

When `strictMatch = TRUE`, this will ensure that all cells in the `ArchRProject` are also represented in the `seRNA` object. This is a nice fail-safe to make sure that the above project subsetting went smoothly. If `strictMatch = FALSE` (the default), then this function will merely throw a warning telling you that not all of your cells have scRNA-seq information and that this could cause problems downstream.

```{r}
#| message: false
#| warning: false
#| output: false

#adding the RNA data to the project together with the ATAC data
projMulti2 <- addGeneExpressionMatrix(input = projMulti2, seRNA = seRNA, strictMatch = TRUE, force = TRUE)
```


## Doublet removal (point 2 in manual)

The last thing that we will do during this project setup phase is filter out any doublets.

```{r}
projMulti2 <- addDoubletScores(projMulti2, force = TRUE)
projMulti2 <- filterDoublets(projMulti2)
```


```{r}
cat("Total number of cells among the samples after doublets removal is:", nCells(projMulti2),". \n")

cat("A total of", nCells(projMulti1)-nCells(projMulti2), "doublets were removed.")
```


```{r}
#Count per condition
condition_after_filter <- table(projMulti2@cellColData$Sample)
condition_after_filter <- as.data.frame(condition_after_filter)
condition_after_filter <- cbind(condition_after_filter, after_filter = c("after", "after", "after", "after", "after"))
condition_after_filter <- setnames(condition_after_filter, c("Sample", "nCells", "filter"))
#condition_after_filter
#condition_sample

filter_diff <- condition_sample[,"nCells"] - condition_after_filter[,"nCells"]
filter_df <- as.data.frame(cbind(Sample = c("CF1", "CF2", "CF7", "CG8", "CG9"),
                   nCells = filter_diff,
                   filter = c("diff", "diff", "diff", "diff", "diff")))

super_frame <- rbind(condition_sample, condition_after_filter)
super_frame$filter = factor(super_frame$filter, levels = c("before", "after"), ordered = TRUE)


p_before_after <- ggplot(super_frame,
                         aes(x=Sample,
                             y=nCells,
                             fill=filter)) + 
    geom_bar(position = "dodge", stat="identity", width=1) +
    ggtitle("Sample before-after Quality Control") +
    theme(legend.position="bottom")
    #theme_ipsum()

p_before_after

# Export dataframe as csv (for report)
write.csv(super_frame, "/Users/raphaelmauron/masters_project/doc/archr_multi/df_nCells_before_after.csv", row.names=T)
```


```{r}
#save plot
plotPDF(p_before_after, name = "Sample-before-after-QC",ArchRProj = projMulti2, addDOC = FALSE)
rm(p_before_after)
```

## Analysis of multiome data in ArchR

### Dimensionality reduction (point 4 in manual)

perform dimensionality reduction using `addIterativeLSI()`. We can do this on the scATAC-seq data via the `TileMatrix` and on the scRNA-seq data via the `GeneExpressionMatrix`.

LSI = Latent Semantic Indexing

```{r}
#| message: false
#| warning: false
#| output: false

#LSI ATAC
projMulti2 <- addIterativeLSI(
  ArchRProj = projMulti2, 
  clusterParams = list(
    resolution = 0.2, 
    sampleCells = 10000,
    n.start = 10
  ),
  saveIterations = FALSE,
  useMatrix = "TileMatrix",
  depthCol = "nFrags",
  name = "LSI_ATAC",
  seed = 5,
  force = T
)
```


```{r}
#| message: false
#| warning: false
#| output: false

#LSI RNA
projMulti2 <- addIterativeLSI(
  ArchRProj = projMulti2, 
  clusterParams = list(
    resolution = 0.2, 
    sampleCells = 10000,
    n.start = 10
  ),
  saveIterations = FALSE,
  useMatrix = "GeneExpressionMatrix", 
  depthCol = "Gex_nUMI",
  varFeatures = 2500,
  firstSelection = "variable",
  binarize = FALSE,
  scaleDims = FALSE,
  name = "LSI_RNA",
  seed = 3,
  force = T
)
```


create a dimensionality reduction that uses information from both the scATAC-seq and scRNA-seq data. 
We will name this `reducedDims` object "LSI_Combined".

```{r}
#LSI from both ATAC and RNA
projMulti2 <- addCombinedDims(projMulti2, reducedDims = c("LSI_ATAC", "LSI_RNA"), name =  "LSI_Combined")
```


### Embedding of reduced dimensions (point 6.1 in manual)

We can create UMAP embeddings for each of these dimensionality reductions.

```{r}
#| message: false
#| warning: false
#| output: false

#generate UMAP from the reduced dimensions performed with LSI
projMulti2 <- addUMAP(projMulti2, reducedDims = "LSI_ATAC", name = "UMAP_ATAC", nNeighbors = 40, minDist = 0.1, force = TRUE)
projMulti2 <- addUMAP(projMulti2, reducedDims = "LSI_RNA", name = "UMAP_RNA", nNeighbors = 40, minDist = 0.1, force = TRUE)
projMulti2 <- addUMAP(projMulti2, reducedDims = "LSI_Combined", name = "UMAP_Combined", nNeighbors = 40, minDist = 0.1, force = TRUE)
```


### Clustering (point 5 from manual)

And then call clusters for each.

```{r}
#| message: false
#| warning: false
#| output: false

projMulti2 <- addClusters(projMulti2, reducedDims = "LSI_ATAC", name = "Clusters_ATAC", resolution = 0.3, maxClusters = 20, force = TRUE)
projMulti2 <- addClusters(projMulti2, reducedDims = "LSI_RNA", name = "Clusters_RNA", resolution = 0.3, maxClusters = 20,force = TRUE)
projMulti2 <- addClusters(projMulti2, reducedDims = "LSI_Combined", name = "Clusters_Combined", resolution = 0.3, maxClusters = 20, force = TRUE)
```


### Plot UMAP Embedding

We can plot how each of these dimensionality reductions look with respect to the clusters called in "LSI_Combined".
It gives an idea of the data obtained from reduced dimension with:
- ATAC only
- RNA only
- ATAC & RNA (hopefully this one gives more compact clusters)

Clusters calculated above are colored.

```{r}
#| message: false
#| warning: false
#| output: false

p1 <- plotEmbedding(projMulti2, name = "Clusters_ATAC", embedding = "UMAP_ATAC", size = 1, labelAsFactors=F, labelMeans=F)
p2 <- plotEmbedding(projMulti2, name = "Clusters_RNA", embedding = "UMAP_RNA", size = 1, labelAsFactors=F, labelMeans=F)
p3 <- plotEmbedding(projMulti2, name = "Clusters_Combined", embedding = "UMAP_Combined", size = 1, labelAsFactors=F, labelMeans=F)

p <- lapply(list(p1,p2,p3), function(x){
  x + guides(color = "none", fill = "none") + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")) +
    theme(
      axis.text.x=element_blank(), 
      axis.ticks.x=element_blank(), 
      axis.text.y=element_blank(), 
      axis.ticks.y=element_blank()
    )
})

#do.call(cowplot::plot_grid, c(list(ncol = 3),p))
rm(p)
```


We can also save this to a PDF file.

```{r}
#save plot
plotPDF(p1, p2, p3, name = "UMAP-scATAC-scRNA-Combined", addDOC = FALSE)
rm(p1, p2, p3)
```


### Confusion matrix clusters ATAC vs RNA (point 5 in manual)

You'll notice that there are some differences between the cluster residence of cells in the scATAC-seq space and cells in the scRNA-seq space. We can visualize these differences using a confusion matrix.

```{r}
cM_atac_rna <- confusionMatrix(paste0(projMulti2$Clusters_ATAC), paste0(projMulti2$Clusters_RNA))
cM_atac_rna <- cM_atac_rna / Matrix::rowSums(cM_atac_rna)

library(pheatmap)
p_atac_rna <- pheatmap::pheatmap(
  mat = as.matrix(cM_atac_rna), 
  color = paletteContinuous("whiteBlue"), 
  border_color = "black"
)
```


```{r}
#save plot
plotPDF(p_atac_rna, name = "Confusion-Matrix-scATAC-scRNA", addDOC = FALSE)
rm(p_atac_rna)
```


## Embedding by sample & by clusters

### UMAP-plot COMBINED

```{r}
#| message: false
#| warning: false
#| output: false

#plot by sample and by clusters
p1 <- plotEmbedding(ArchRProj = projMulti2, colorBy = "cellColData", name = "Sample", embedding = "UMAP_Combined")
#p1

p2 <- plotEmbedding(ArchRProj = projMulti2, colorBy = "cellColData", name = "Clusters_Combined", embedding = "UMAP_Combined")
#p2

p3 <- plotEmbedding(ArchRProj = projMulti2, colorBy = "cellColData", name = "Conditions", embedding = "UMAP_Combined", alpha = 0.5, pal = c("CF" = "white","CG" = "green"))
#p3
p4 <- plotEmbedding(ArchRProj = projMulti2, colorBy = "cellColData", name = "Conditions", embedding = "UMAP_Combined", alpha = 0.5, pal = c("CF" = "blue","CG" = "white"))
#p4
p5 <- plotEmbedding(ArchRProj = projMulti2, colorBy = "cellColData", name = "Conditions", embedding = "UMAP_Combined", alpha = 0.35, pal = c("CF" = "blue","CG" = "green"))
#p5
```


```{r}
#save plot
plotPDF(p1, p2, p3, p4, p5, name = "UMAP-Combined-sample-clusters", addDOC = FALSE)
rm(p1, p2, p3, p4)
```

### UMAP-plot ATAC

```{r}
#| message: false
#| warning: false
#| output: false

#plot by sample and by clusters
p1 <- plotEmbedding(ArchRProj = projMulti2, colorBy = "cellColData", name = "Sample", embedding = "UMAP_ATAC")
#p1

p2 <- plotEmbedding(ArchRProj = projMulti2, colorBy = "cellColData", name = "Clusters_ATAC", embedding = "UMAP_ATAC")
#p2

p3 <- plotEmbedding(ArchRProj = projMulti2, colorBy = "cellColData", name = "Conditions", embedding = "UMAP_ATAC", alpha = 0.5, pal = c("CF" = "white","CG" = "green"))
#p3
p4 <- plotEmbedding(ArchRProj = projMulti2, colorBy = "cellColData", name = "Conditions", embedding = "UMAP_ATAC", alpha = 0.5, pal = c("CF" = "blue","CG" = "white"))
#p4
p5 <- plotEmbedding(ArchRProj = projMulti2, colorBy = "cellColData", name = "Conditions", embedding = "UMAP_ATAC", alpha = 0.35, pal = c("CF" = "blue","CG" = "green"))
#p5
```


```{r}
#save plot
plotPDF(p1, p2, p3, p4, p5, name = "UMAP-ATAC-sample-clusters", addDOC = FALSE)
rm(p1, p2, p3, p4)
```


### UMAP-plot RNA

```{r}
#| message: false
#| warning: false
#| output: false

#plot by sample and by clusters
p1 <- plotEmbedding(ArchRProj = projMulti2, colorBy = "cellColData", name = "Sample", embedding = "UMAP_RNA")
#p1

p2 <- plotEmbedding(ArchRProj = projMulti2, colorBy = "cellColData", name = "Clusters_RNA", embedding = "UMAP_RNA")
#p2

p3 <- plotEmbedding(ArchRProj = projMulti2, colorBy = "cellColData", name = "Conditions", embedding = "UMAP_RNA", alpha = 0.5, pal = c("CF" = "white","CG" = "green"))
#p3
p4 <- plotEmbedding(ArchRProj = projMulti2, colorBy = "cellColData", name = "Conditions", embedding = "UMAP_RNA", alpha = 0.5, pal = c("CF" = "blue","CG" = "white"))
#p4
p5 <- plotEmbedding(ArchRProj = projMulti2, colorBy = "cellColData", name = "Conditions", embedding = "UMAP_RNA", alpha = 0.35, pal = c("CF" = "blue","CG" = "green"))
#p5
```


```{r}
#save plot
plotPDF(p1, p2, p3, p4, p5, name = "UMAP-RNA-sample-clusters", addDOC = FALSE)
rm(p1, p2, p3, p4)
```


## HARMONY: Batch effect correction (point 4.4 in manual)

Helps for more dense clusters
(Not the same as LSI)

```{r}
#| message: false
#| warning: false
#| output: false

#Harmony Combined
projMulti2 <- addHarmony(
  ArchRProj = projMulti2,
  reducedDims = "LSI_Combined",
  name = "Harmony",
  groupBy = "Sample",
  theta = 0.001,
  lambda = 1,
  force = T
)

#Harmony ATAC
projMulti2 <- addHarmony(
  ArchRProj = projMulti2,
  reducedDims = "LSI_ATAC",
  name = "Harmony_ATAC",
  groupBy = "Sample",
  theta = 0.001,
  lambda = 1,
  force = T
)

#Harmony RNA
projMulti2 <- addHarmony(
  ArchRProj = projMulti2,
  reducedDims = "LSI_RNA",
  name = "Harmony_RNA",
  groupBy = "Sample",
  force = T
)
```


## Dimensionality reduction after Harmony (point 6.3 in manual)

### UMAP

```{r}
#| message: false
#| warning: false
#| output: false

#dimensionality reduction (Harmony, not LSI) COMBINED
projMulti2 <- addUMAP(
  ArchRProj = projMulti2,
  reducedDims = "Harmony",
  name = "UMAPHarmony",
  nNeighbors = 40,
  minDist = 0.1,
  metric = "cosine",
  force = T
)

#dimensionality reduction (Harmony, not LSI) ATAC
projMulti2 <- addUMAP(
  ArchRProj = projMulti2,
  reducedDims = "Harmony_ATAC",
  name = "UMAPHarmony_ATAC",
  nNeighbors = 40,
  minDist = 0.1,
  metric = "cosine",
  force = T
)

#dimensionality reduction (Harmony, not LSI) RNA
projMulti2 <- addUMAP(
  ArchRProj = projMulti2,
  reducedDims = "Harmony_RNA",
  name = "UMAPHarmony_RNA",
  nNeighbors = 40,
  minDist = 0.1,
  metric = "cosine",
  force = T
)
```


### Harmony-UMAP-plot
#### Combined

```{r}
p1 <- plotEmbedding(ArchRProj = projMulti2, 
                    colorBy = "cellColData", 
                    name = "Sample", 
                    embedding = "UMAPHarmony")

p2 <- plotEmbedding(ArchRProj = projMulti2, 
                    colorBy = "cellColData", 
                    name = "Clusters_Combined", 
                    embedding = "UMAPHarmony")

p3 <- plotEmbedding(ArchRProj = projMulti2, 
                    colorBy = "cellColData", 
                    name = "Conditions", 
                    embedding = "UMAPHarmony",
                    alpha = 0.35, pal = c("CF" = "blue","CG" = "green")
                    )

p4 <- plotEmbedding(ArchRProj = projMulti2, 
                    colorBy = "cellColData", 
                    name = "Conditions", 
                    embedding = "UMAPHarmony",
                    alpha = 0.35, pal = c("CF" = "white","CG" = "green")
                    )

p5 <- plotEmbedding(ArchRProj = projMulti2, 
                    colorBy = "cellColData", 
                    name = "Conditions", 
                    embedding = "UMAPHarmony",
                    alpha = 0.35, pal = c("CF" = "blue","CG" = "white")
                    )
#p1
#p2
#p3
#p4
#p5
```


```{r}
#save plot
plotPDF(p1, p2, p3, p4, p5, name = "UMAP-Harmony-Combined-sample-clusters", addDOC = FALSE)
rm(p1, p2, p3, p4, p5)
```


#### ATAC

```{r}
p1 <- plotEmbedding(ArchRProj = projMulti2, 
                    colorBy = "cellColData", 
                    name = "Sample", 
                    embedding = "UMAPHarmony_ATAC")

p2 <- plotEmbedding(ArchRProj = projMulti2, 
                    colorBy = "cellColData", 
                    name = "Clusters_ATAC", 
                    embedding = "UMAPHarmony_ATAC")

p3 <- plotEmbedding(ArchRProj = projMulti2, 
                    colorBy = "cellColData", 
                    name = "Conditions", 
                    embedding = "UMAPHarmony_ATAC",
                     alpha = 0.35, pal = c("CF" = "blue","CG" = "green")
                    )
p4 <- plotEmbedding(ArchRProj = projMulti2, 
                    colorBy = "cellColData", 
                    name = "Conditions", 
                    embedding = "UMAPHarmony_ATAC",
                     alpha = 0.35, pal = c("CF" = "white","CG" = "green")
                    )
p5 <- plotEmbedding(ArchRProj = projMulti2, 
                    colorBy = "cellColData", 
                    name = "Conditions", 
                    embedding = "UMAPHarmony_ATAC",
                     alpha = 0.35, pal = c("CF" = "blue","CG" = "white")
                    )
#p1
#p2
#p3
#p4
#p5
```


```{r}
#save plot
plotPDF(p1, p2, p3, p4, p5, name = "UMAP-Harmony-ATAC-sample-clusters", addDOC = FALSE)
rm(p1, p2, p3, p4, p5)
```


#### RNA

```{r}
p1 <- plotEmbedding(ArchRProj = projMulti2, 
                    colorBy = "cellColData", 
                    name = "Sample", 
                    embedding = "UMAPHarmony_RNA")

p2 <- plotEmbedding(ArchRProj = projMulti2, 
                    colorBy = "cellColData", 
                    name = "Clusters_RNA", 
                    embedding = "UMAPHarmony_RNA")

p3 <- plotEmbedding(ArchRProj = projMulti2, 
                    colorBy = "cellColData", 
                    name = "Conditions", 
                    embedding = "UMAPHarmony_RNA",
                    alpha = 0.35, pal = c("CF" = "blue","CG" = "green")
                    )

p4 <- plotEmbedding(ArchRProj = projMulti2, 
                    colorBy = "cellColData", 
                    name = "Conditions", 
                    embedding = "UMAPHarmony_RNA",
                    alpha = 0.35, pal = c("CF" = "white","CG" = "green")
                    )

p5 <- plotEmbedding(ArchRProj = projMulti2, 
                    colorBy = "cellColData", 
                    name = "Conditions", 
                    embedding = "UMAPHarmony_RNA",
                    alpha = 0.35, pal = c("CF" = "blue","CG" = "white")
                    )
#p1
#p2
#p3
#p4
#p5
```


```{r}
#save plot
plotPDF(p1, p2, p3, p4, p5, name = "UMAP-Harmony-RNA-sample-clusters", addDOC = FALSE)
rm(p1, p2, p3, p4, p5)
```


## Gene scores and Marker genes (point 7 in manaul)

### Gene / Marker / motif list:

```{r}
#include your marker gene list here
my_markers <- c(
    "Wfs1", # RR3 markers
    "Dkk3",
    "Prox1",
    "Egfr",
    "Ptn",
    "Efna5",
    "Vegfa",
    "Zic1",
    "Zic2",
    "Atoh1",
    "Sox2",
    "Nr4a2",
    "Pparg",
    "Rxra",
    "Nr2f6",
    "Hic1",
    "Sox6",

    # #Neurodegenerative disease marker
    # "CD33",
    # "PSEN1",
    # "PSEN2",
    # "TREM2",
    "GBA", #Parkinson markers
    "LRRK2",
    "PINK1",
    "UCHL1",
    "VPS35"
)
my_markers <- unique(my_markers)
```


### Tweak and bias correction for multiome data

```{r}
#| message: false
#| warning: false
#| output: false

#bias correction
se <- getMarkerFeatures(ArchRProj = projMulti2,
                        groupBy = "Clusters_ATAC", #"Clusters_Combined",
                        bias = c("TSSEnrichment", #snATAC-seq data quality
                                 "log10(nFrags)", #read depth for snATAC 
                                 "log10(Gex_nUMI)") #read depth for snRNA 
                        )

#plot heatmap of all the marker genes
heatmap_gex <- plotMarkerHeatmap(
  seMarker = se, 
  cutOff = "FDR <= 0.01 & Log2FC >= 0.5",
  #nPrint = 5, #max number of gene to print per cluster
  transpose = T,
  labelMarkers = my_markers #c("Gba", "Lrrk2", "Pink1", "Uchl1", "Vps35")#specify the markers you want a label on
  )

#draw(heatmap_gex, heatmap_legend_side = "bot", annotation_legend_side = "bot")
```


```{r}
#save plot
plotPDF(heatmap_gex, 
        name = "GeneExpression-Marker-Heatmap",
        width = 12,
        height = 7,
        addDOC = FALSE)
rm(heatmap_gex)
```


### Get marker genes
```{r}
#| message: false
#| warning: false

# list of marker genes per cluster (ranked in comparison to the markers from the other markers)
markerList <- getMarkers(se, cutOff = "FDR <= 0.01 & Log2FC >= 1.25") 

i <- 1
top <- 20
for (cluster in 1:length(markerList@listData)) {
    if (nrow(markerList@listData[[cluster]]["name"]) >= top) {
        if (i == 1) {
            my_row <- head(markerList@listData[[cluster]]["name"],top)
            df_top <- as.data.frame(my_row)
            colnames(df_top)[1] <- gsub(" ", "",paste("Cluster", cluster))
        } else {
        df_top <- cbind(df_top, head(markerList@listData[[cluster]]["name"],top))
        colnames(df_top)[i] <- gsub(" ", "",paste("Cluster", cluster))
        }
    } else {
        next
    }
    i <- i + 1
}
rm(cluster, i)

# ROWNAMES
row_list <- c()
for (row in 1:top) {
    row_list <- append(row_list, gsub(" ", "",paste("MarkerGene", row)))
}

rownames(df_top) <- row_list
df_top
rm(row, row_list, top)
```

### DF top3 --> create list of markers to pass through next function
```{r}
#| message: false
#| warning: false

# list of marker genes per cluster (ranked in comparison to the markers from the other markers)
markerList <- getMarkers(se, cutOff = "FDR <= 0.01 & Log2FC >= 1.25") 

i <- 1
top <- 3
for (cluster in 1:length(markerList@listData)) {
    if (nrow(markerList@listData[[cluster]]["name"]) >= top) {
        if (i == 1) {
            my_row <- head(markerList@listData[[cluster]]["name"],top)
            df_top3 <- as.data.frame(my_row)
            colnames(df_top3)[1] <- gsub(" ", "",paste("Cluster", cluster))
        } else {
        df_top3 <- cbind(df_top3, head(markerList@listData[[cluster]]["name"],top))
        colnames(df_top3)[i] <- gsub(" ", "",paste("Cluster", cluster))
        }
    } else {
        next
    }
    i <- i + 1
}
rm(cluster, i)

# ROWNAMES
row_list <- c()
for (row in 1:top) {
    row_list <- append(row_list, gsub(" ", "",paste("MarkerGene", row)))
}
rownames(df_top3) <- row_list
df_top3


# take every element of the small list and create 1 list
list_top3_df <- as.list(df_top3)
list_top3 <- c()

for (c in 1:length(list_top3_df)) {
    for (i in 1:top) {
        list_top3 <- append(list_top3, list_top3_df[[c]][i])
        list_top3 <- unique(list_top3)
    }
}
list_top3

# remove variable
rm(row, row_list, top, list_top3_df, c, i)
```

Save dataframe as csv
```{r}
# Export dataframe as csv (for report)
write.csv(t(df_top3), "/Users/raphaelmauron/masters_project/doc/archr_multi/df_top3_markergenes.csv", row.names=T)
```


### Visualizing Marker Genes on an Embedding
(skip?) --> does not make sense to embed marker genes on ATAC cluster. signal is too low
```{r}
#| message: false
#| warning: false
#| output: false

p <- plotEmbedding(
    ArchRProj = projMulti2,
    colorBy = "GeneExpressionMatrix",
    name = c(my_markers, list_top3),
    embedding = "UMAPHarmony_ATAC", #"UMAPHarmony", #can select the dimensionality reduction here
    quantCut = c(0.01, 0.95),
    imputeWeights = NULL
)
```

(skip?)
```{r}
#| message: false
#| warning: false
#| output: false

#plot 1 embedding per selected genes
p <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})

#uncomment to plot here, but might overload RStudio
#do.call(cowplot::plot_grid, c(list(ncol = 1),p))
```

(skip?)
```{r}
#save plot
plotPDF(plotList = p, 
        name = "Plot-UMAP-Marker-Genes-WO-Imputation.pdf", 
        ArchRProj = projMulti2,
        addDOC = FALSE,
        width = 5,
        height = 5)
rm(p)
```


### Marker genes imputation with MAGIC (point 7.5 in manual)

(skip?)
```{r}
#| message: false
#| warning: false
#| output: false

projMulti2 <- addImputeWeights(ArchRProj = projMulti2,
                               reducedDims = "LSI_ATAC" #"LSI_Combined"
                               )
```

(skip?)
```{r}
#| message: false
#| warning: false
#| output: false

p <- plotEmbedding(
    ArchRProj = projMulti2, 
    colorBy = "GeneExpressionMatrix", 
    name = c(my_markers, list_top3), 
    embedding = "UMAPHarmony_ATAC", #"UMAPHarmony", #can select the dimensionality reduction here
    imputeWeights = getImputeWeights(projMulti2)
)
```

(skip?)
```{r}
#| message: false
#| warning: false
#| output: false

#Rearrange for grid plotting
p <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})

#uncomment to plot, might overload the session
#do.call(cowplot::plot_grid, c(list(ncol = 3),p))
```

(skip?) --> At least now there is a strong enough signal
```{r}
#| message: false
#| warning: false
#| output: false

#save plot
plotPDF(plotList = p, 
        name = "Plot-UMAP-Marker-Genes-W-Imputation.pdf", 
        ArchRProj = projMulti2,
        addDOC = FALSE,
        width = 5,
        height = 5)
rm(p)
```


### Track Plotting (point 7.6 in manual)
!!! browse the local chromatin accessibility at these marker genes on a per cluster basis !!!

```{r}
#| message: false
#| warning: false
#| output: false
#| include: false #prevent to overload the session but this chunk won't be visible if you render

p <- plotBrowserTrack(
     ArchRProj = projMulti2, 
     groupBy = "Clusters_ATAC", #Clusters_Combined", 
     geneSymbol = c(my_markers, list_top3), 
     upstream = 50000,
     downstream = 50000
)
```


```{r}
#| message: false
#| warning: false
#| output: false

#save plot
plotPDF(plotList = p, 
        name = "Plot-Tracks-Marker-Genes.pdf", 
        ArchRProj = projMulti2,
        addDOC = FALSE,
        width = 5,
        height = 5)
rm(p)
```


```{r}
#save project since we will change project now
saveArchRProject(ArchRProj = projMulti2, outputDirectory = "Save-ProjMulti2", load = F)
```


```{r}
#load the project from last saved project (if necessary)
#library(ArchR)
#projMulti2 <- loadArchRProject(path = "./Save-ProjMulti2", force = FALSE, showLogo = F)
```

## Annotate cells (point 8 in manual)

Since we don't have our cells labeled, we need to infer their origin from the clusters we have and the http://mousebrain.org database:

### Integration of db
Done in the way the authors integrate RNA (when snATAC-seq is not from multiome analysis (snATAC + snRNA)).

Here integrate database which will allow to annotate each cells by running probability compared to the *GeneExpressionMatrix* we have from our own snRNA-seq.

```{r}
#| message: false
#| warning: false
#| output: false

#loading the database file in seurat format (.Rds)

#setwd("/Users/raphaelmauron/archr_rr3/data-raw/ref_data/mousebrain_tax4_subsampled.Rds")

se_RNA_mousebrain_data <- readRDS(file = "/Users/raphaelmauron/archr_rr3/data-raw/ref_data/mousebrain_tax4_subsampled.Rds")
se_RNA_mousebrain_data
```


```{r}
#| message: false
#| warning: false
#| output: false

#check requirement for seurat object before integration
#1
"RNA" %in% names(se_RNA_mousebrain_data@assays)

#2 all the cell types found our sample:
unique(se_RNA_mousebrain_data@meta.data$TaxonomyRank4)
```


```{r}
#| message: false
#| warning: false
#| output: false

#unconstrained method (8.1.1 in manual)
#TaxonomyRank1
projMulti3 <- addGeneIntegrationMatrix(
    ArchRProj = projMulti2, 
    useMatrix = "GeneExpressionMatrix",
    matrixName = "GeneIntegrationMatrix_db_1",
    reducedDims = "Harmony", #"LSI_Combined",
    seRNA = se_RNA_mousebrain_data,
    addToArrow = FALSE,
    groupRNA = "TaxonomyRank1",
    nameCell = "predictedCell_Un_1", #store cell ID from matched RNA expr
    nameGroup = "predictedGroup_Un_1", #store the group ID
    nameScore = "predictedScore_Un_1" #store the cross-platform integration score
)

p1 <- plotEmbedding(
    projMulti3,
    colorBy = "cellColData",
    name = "predictedGroup_Un_1",
    embedding = "UMAPHarmony",
    pal = paletteDiscrete(values = unique(projMulti3@cellColData@listData[["predictedGroup_Un_1"]]))
)

p1_1 <- plotEmbedding(
    projMulti3,
    colorBy = "cellColData",
    name = "predictedGroup_Un_1",
    embedding = "UMAPHarmony_ATAC",
    pal = paletteDiscrete(values = unique(projMulti3@cellColData@listData[["predictedGroup_Un_1"]]), set = "stallion2")
)

#p1
#p1_1
```


```{r}
#| message: false
#| warning: false
#| output: false

#TaxonomyRank2
projMulti3 <- addGeneIntegrationMatrix(
    ArchRProj = projMulti2, 
    useMatrix = "GeneExpressionMatrix",
    matrixName = "GeneIntegrationMatrix_db_2",
    reducedDims = "Harmony", #"LSI_Combined"
    seRNA = se_RNA_mousebrain_data,
    addToArrow = FALSE,
    groupRNA = "TaxonomyRank2",
    nameCell = "predictedCell_Un_2",
    nameGroup = "predictedGroup_Un_2",
    nameScore = "predictedScore_Un_2"
)

p2 <- plotEmbedding(
    projMulti3,
    colorBy = "cellColData",
    name = "predictedGroup_Un_2",
    embedding = "UMAPHarmony",
    pal = paletteDiscrete(values = unique(projMulti3@cellColData@listData[["predictedGroup_Un_2"]]))
)

p2_1 <- plotEmbedding(
    projMulti3,
    colorBy = "cellColData",
    name = "predictedGroup_Un_2",
    embedding = "UMAPHarmony_ATAC",
    pal = paletteDiscrete(values = unique(projMulti3@cellColData@listData[["predictedGroup_Un_2"]]))
)

p2
p2_1
```


```{r}
#| message: false
#| warning: false
#| output: false

#TaxonomyRank4
projMulti3 <- addGeneIntegrationMatrix(
    ArchRProj = projMulti2, 
    useMatrix = "GeneExpressionMatrix",
    matrixName = "GeneIntegrationMatrix_db_4",
    reducedDims = "Harmony", #"LSI_Combined"
    seRNA = se_RNA_mousebrain_data,
    addToArrow = TRUE, #set TRUE to the Taxonomy you want to add to the ArrowFiles
    groupRNA = "TaxonomyRank4",
    nameCell = "predictedCell_Un_4",
    nameGroup = "predictedGroup_Un_4",
    nameScore = "predictedScore_Un_4"
)


p4 <- plotEmbedding(
    projMulti3,
    colorBy = "cellColData",
    name = "predictedGroup_Un_4",
    embedding = "UMAPHarmony",
    pal = paletteDiscrete(values = unique(projMulti3@cellColData@listData[["predictedGroup_Un_4"]]), set = "stallion")

)

p4_1 <- plotEmbedding(
    projMulti3,
    colorBy = "cellColData",
    name = "predictedGroup_Un_4",
    embedding = "UMAPHarmony_ATAC",
    pal = paletteDiscrete(values = unique(projMulti3@cellColData@listData[["predictedGroup_Un_4"]]), set = "stallion")

)

#p4
#p4_1
```


```{r}
#| message: false
#| warning: false
#| output: false

#TaxonomyRank3
projMulti3 <- addGeneIntegrationMatrix(
    ArchRProj = projMulti2, 
    useMatrix = "GeneExpressionMatrix",
    matrixName = "GeneIntegrationMatrix_db_3",
    reducedDims = "Harmony", #"LSI_Combined"
    seRNA = se_RNA_mousebrain_data,
    addToArrow = FALSE,
    force = TRUE, #to allow rerun
    groupRNA = "TaxonomyRank3",
    nameCell = "predictedCell_Un_3",
    nameGroup = "predictedGroup_Un_3",
    nameScore = "predictedScore_Un_3"
)

p3 <- plotEmbedding(
    projMulti3,
    colorBy = "cellColData",
    name = "predictedGroup_Un_3",
    embedding = "UMAPHarmony",
    pal = paletteDiscrete(values = unique(projMulti3@cellColData@listData[["predictedGroup_Un_3"]]))
)

p3_1 <- plotEmbedding(
    projMulti3,
    colorBy = "cellColData",
    name = "predictedGroup_Un_3",
    embedding = "UMAPHarmony_ATAC",
    pal = paletteDiscrete(values = unique(projMulti3@cellColData@listData[["predictedGroup_Un_3"]]))
)

#p3
```


```{r}
#save plot
plotPDF(p1, p1_1, p2, p2_1, p3, p3_1, p4, p4_1, 
        name = "Plot-HarmonyUMAP-Cell-Annotation.pdf", 
        ArchRProj = projMulti3,
        addDOC = FALSE,
        width = 5,
        height = 5)
rm(p1, p1_1, p2, p2_1, p3, p3_1, p4, p4_1)
```


```{r}
#new category which specifies the condition and the cell type
# Condition_CellType
projMulti3 <- addCellColData(
    ArchRProj = projMulti3, 
    data = gsub(" ", "_", paste0(projMulti3@cellColData$Conditions, "_x_", projMulti3@cellColData$predictedGroup_Un_3)), 
    name = "Condition_CellType", 
    cells = getCellNames(projMulti3), 
    force = TRUE)

projMulti3 <- addCellColData(
    ArchRProj = projMulti3, 
    data = gsub(" ", "_", paste0(projMulti3@cellColData$predictedGroup_Un_3, "_x_", projMulti3@cellColData$Conditions)), 
    name = "CellType_Condition", 
    cells = getCellNames(projMulti3), 
    force = TRUE)

#return the unique tags from this new category
unique(projMulti3@cellColData@listData[["CellType_Condition"]])
```

```{r}
df_cond_cell <- as.data.frame(table(projMulti3@cellColData@listData[["CellType_Condition"]]))
df_cond_cell <- setnames(df_cond_cell, c("CellType_Condition", "nCells"))
df_cond_cell <- df_cond_cell %>% add_column(Conditions = c("CF", "CG", "CF", "CG", "CF", "CG", "CF", "CG", "CF", "CG", "CF", "CG", "CF", "CG", "CF", "CG", "CF", "CG", "CF", "CG"))
df_cond_cell
```

```{r}
p_cond <- ggplot(df_cond_cell,                                 
       aes(x = CellType_Condition,
           y = nCells,
           fill = Conditions)) + 
  geom_bar(stat = "identity")+
  ggtitle("Number of cells per condition") +
    theme(axis.text.x = element_text(angle = 60, hjust=1)) #+
    #scale_fill_manual("Condition", values = c("CF" = "blue", "CG" = "green"))
#p_cond
```


```{r}
#save plot
plotPDF(p_cond, 
        name = "Plot-nCells_Condition_CellType.pdf", 
        ArchRProj = projMulti3,
        addDOC = FALSE,
        width = 20,
        height = 10)
rm(p_cond)
```


```{r}
#| warning: false
#| message: false
saveArchRProject(ArchRProj = projMulti3, outputDirectory = "Save-ProjMulti3", load = F)
```


```{r}
#load the project from last saved project (if necessary)
#library(ArchR)
#projMulti3 <- loadArchRProject(path = "./Save-ProjMulti3", force = FALSE, showLogo = TRUE)
```


## Calling Peaks (point 9 & 10 in manual)

```{r}
#| message: false
#| warning: false
#| output: false

projMulti4 <- projMulti3

#add coverage (point 9 in manual)
projMulti4 <- addGroupCoverages(
    ArchRProj = projMulti4, 
    groupBy = "Clusters_Combined" #in CellColData, 
    )

#get path to the python tool installed through miniconda (MACS2)
projMulti4 <- addReproduciblePeakSet(
    ArchRProj = projMulti4, 
    groupBy = "Clusters_Combined", #in CellColData, 
    pathToMacs2 = "/usr/local/bin/macs2"#"/Users/raphaelmauron/Library/Python/3.9/bin/macs2"
        )

#add peaks just found
projMulti4 <- addPeakMatrix(ArchRProj = projMulti4)

#peak2genes (point 15.3 in manual)
projMulti4 <- addPeak2GeneLinks(
    ArchRProj = projMulti4, 
    reducedDims = "Harmony", #"LSI_Combined", 
    useMatrix = "GeneExpressionMatrix")

p2g <- getPeak2GeneLinks(ArchRProj = projMulti4)

p2g[[1]]
```


```{r}
#check the available matrices in the project. Should get "PeakMatrix"
getAvailableMatrices(projMulti4) 
```


## Identifying Marker Peaks (point 11 in manual)

### Marker Peaks

```{r}
#Our scRNA labels to remind ourselves of the cell types that we are working with in projMulti4
table(projMulti4@cellColData@listData[["CellType_Condition"]])
```


```{r}
#pairwise testing withing "Cholinergic,_monoaminergic_and_peptidergic_neurons" cluster
marker_Cholinergic <- getMarkerFeatures(
  ArchRProj = projMulti4, 
  useMatrix = "PeakMatrix",
  groupBy = "CellType_Condition",
  testMethod = "wilcoxon",
  bias = c("TSSEnrichment", 
            "log10(nFrags)", 
            "log10(Gex_nUMI)"),
  useGroups = "Cholinergic,_monoaminergic_and_peptidergic_neurons_x_CF",
  bgdGroups = "Cholinergic,_monoaminergic_and_peptidergic_neurons_x_CG"
)


marker_Cholinergic_significant <- as.data.frame(marker_Cholinergic@assays@data@listData)
marker_Cholinergic_significant <- setnames(marker_Cholinergic_significant, c("Log2FC", "Mean", "FDR", "Pval", "MeanDiff", "AUC", "MeanBGD"))
marker_Cholinergic_significant <- marker_Cholinergic_significant[
    ((marker_Cholinergic_significant$FDR <= 0.5) & (marker_Cholinergic_significant$Log2FC >= 1)),] #& (marker_Cholinergic_significant$Log2FC >= 1 | marker_Cholinergic_significant$Log2FC <= 1 )),]
marker_Cholinergic_significant <- marker_Cholinergic_significant[
    ((marker_Cholinergic_significant$Log2FC >= 1)),]
marker_Cholinergic_significant <- marker_Cholinergic_significant %>% drop_na()
```


```{r}

#pairwise testing withing "Cholinergic,_monoaminergic_and_peptidergic_neurons" cluster
marker_Oligodendrocytes <- getMarkerFeatures(
  ArchRProj = projMulti4, 
  useMatrix = "PeakMatrix",
  groupBy = "CellType_Condition",
  testMethod = "wilcoxon",
  bias = c("TSSEnrichment", 
            "log10(nFrags)", 
            "log10(Gex_nUMI)"),
  useGroups = "Oligodendrocytes_x_CF",
  bgdGroups = "Oligodendrocytes_x_CG"
)

marker_Oligodendrocytes_significant <- as.data.frame(marker_Oligodendrocytes@assays@data@listData)
marker_Oligodendrocytes_significant <- setnames(marker_Oligodendrocytes_significant, c("Log2FC", "Mean", "FDR", "Pval", "MeanDiff", "AUC", "MeanBGD"))
marker_Oligodendrocytes_significant <- marker_Oligodendrocytes_significant[
    ((marker_Oligodendrocytes_significant$FDR <= 0.1) & (marker_Oligodendrocytes_significant$Log2FC >= 1 | marker_Oligodendrocytes_significant$Log2FC <= 1 )),]
marker_Oligodendrocytes_significant <- marker_Oligodendrocytes_significant %>% drop_na()
```



```{r}
#| message: false
#| warning: false
#| output: false

#indentify marker peaks by calling addMarkerFeatures()
markersPeaks <- getMarkerFeatures(
    ArchRProj = projMulti4, 
    useMatrix = "PeakMatrix", 
    groupBy = "predictedGroup_Un_3", #in CellColData
    bias = c("TSSEnrichment", 
             "log10(nFrags)", 
             "log10(Gex_nUMI)"), 
    testMethod = "wilcoxon"
)
```



```{r}
#use the getMarkers() function to retrieve particular slices of this SummarizedExperiment that we are interested in
#return a list of DataFrame objects, one for each cell group
markerList <- getMarkers(markersPeaks, cutOff = "FDR <= 0.01 & Log2FC >= 1")
markerList
```


```{r}
#marker peaks for a specific cell group
markerList$Oligodendrocytes #change cell type
```


```{r}
#return a GRangesList instead of a DataFrame object.
markerList <- getMarkers(markersPeaks, 
                         cutOff = "FDR <= 0.01 & Log2FC >= 1", 
                         returnGR = TRUE)
markerList
```


```{r}
#markerList$Oligodendrocytes #change cell type
```

```{r}
#return a GRangesList instead of a DataFrame object.
markerList_Cholinergic <- getMarkers(marker_Cholinergic, 
                         cutOff = "FDR <= 0.01 & Log2FC >= 1", 
                         returnGR = TRUE)
markerList_Cholinergic


markerList_Oligodendrocytes <- getMarkers(marker_Oligodendrocytes, 
                         cutOff = "FDR <= 0.01 & Log2FC >= 1", 
                         returnGR = TRUE)
markerList_Oligodendrocytes
```


### Plotting Marker Peaks

multiple plotting functions to interact with the SummarizedExperiment objects returned by getMarkerFeatures()

#### Marker Peak Heatmaps

```{r}
#| message: false
#| warning: false
#| output: false

heatmapPeaks <- plotMarkerHeatmap(
  seMarker = markersPeaks, 
  cutOff = "FDR <= 0.1 & Log2FC >= 0.5",
  transpose = TRUE
)
```


```{r}
#draw(heatmapPeaks, heatmap_legend_side = "bot", annotation_legend_side = "bot")
```


```{r}
#save plot
plotPDF(heatmapPeaks, name = "Peak-Marker-Heatmap", width = 8, height = 6, ArchRProj = projMulti4, addDOC = FALSE)
rm(heatmapPeaks)
```


### MA and Volcano Plots

We can plot MA or Volcano plot for any individual cell group.
Here, only VolcanoPlots

#### Volcano plot

```{r}
#| message: false
#| warning: false
#| output: false

#Volcano plot
cell_types <- unique(projMulti4@cellColData@listData[["predictedGroup_Un_3"]])

for (cell in cell_types) {
pv <- plotMarkers(
    seMarker = markersPeaks,
    name = cell,#"Oligodendrocytes", #change cell name
    cutOff = "FDR <= 0.1 & Log2FC >= 1",
    plotAs = "Volcano" #MA
    ) + ggtitle(cell)
#print(pv)
plot_type <- "volcano-markers"
cell_type <- cell

plotPDF(pv, name = gsub(" ", "-",paste(plot_type, cell_type)), width = 5, height = 5, ArchRProj = projMulti4, addDOC = FALSE)
}
rm(plot_type, cell_type)
```


```{r}
pv <- plotMarkers(
    seMarker = marker_Cholinergic,
    name = "Cholinergic,_monoaminergic_and_peptidergic_neurons_x_CF", #change cell name
    cutOff = "FDR <= 0.1 & (Log2FC >= 1 | Log2FC <= 1)",
    plotAs = "Volcano" #MA
    ) +
    ggtitle("Cholinergic,_monoaminergic_and_peptidergic_neurons_x_CF") +
    ylab("-log10(FDR)") +
    xlab("Log2 Fold Change")
print(pv)


pv <- plotMarkers(
    seMarker = marker_Oligodendrocytes,
    name = "Oligodendrocytes_x_CF", #change cell name
    cutOff = "(FDR <= 0.1) & (Log2FC >= 1 | Log2FC <= 1)",
    plotAs = "Volcano" #MA
    ) + ggtitle("Oligodendrocytes_x_CF")
print(pv)
```

### Pairwise Testing Between Groups

!!! ArchR also enables standard differential testing using the same getMarkerFeatures() function. The trick is to set useGroups to one of the two cell groups and bgdGroups to the other cell group.

```{r}
#| message: false
#| warning: false
#| output: false

# # group 1: useGroups
# # group 2: bgdGroups
# markerTest <- getMarkerFeatures( ### markerTest is also used in other downstream analysis
#   ArchRProj = projMulti4, 
#   useMatrix = "PeakMatrix",
#   groupBy = "predictedGroup_Un_3",
#   testMethod = "wilcoxon",
#   bias = c("TSSEnrichment", 
#              "log10(nFrags)", 
#              "log10(Gex_nUMI)"),
#   useGroups = "Oligodendrocytes", #cell type 1
#   bgdGroups = "Immature neural" #cell type 2
# )
```

### markerConditions

```{r}
#| message: false
#| warning: false
#| output: false

# # group 1: useGroups
# # group 2: bgdGroups
getAvailableMatrices(projMulti4)
#indentify marker peaks by calling addMarkerFeatures()
markersPeaksCondition <- getMarkerFeatures(
    ArchRProj = projMulti4, 
    useMatrix = "PeakMatrix", #"PeakMatrix", 
    groupBy = "Conditions", #in CellColData
    bias = c("TSSEnrichment", 
             "log10(nFrags)", 
             "log10(Gex_nUMI)"), 
    testMethod = "wilcoxon",
    useGroups = "CF", #cell type 1
    bgdGroups = "CG" #cell type 2
)
```

```{r}
#plot Volcano
pv <- plotMarkers(
    seMarker = markersPeaksCondition,
    name = "CF", #change cell type
    cutOff = "(FDR <= 0.1) & (Log2FC >= 1 | Log2FC <= 1)",#"FDR <= 0.1 & abs(Log2FC) >= 0.5",
    plotAs = "Volcano")
pv
```


```{r}
#save plots
plotPDF(pv, name = "Conditions-PeakMarkers-Volcano", width = 5, height = 5, ArchRProj = projMulti4, addDOC = FALSE)
rm(pv)
```


```{r}
#| message: false
#| warning: false
#| output: false

# # group 1: useGroups
# # group 2: bgdGroups
getAvailableMatrices(projMulti4)
#indentify marker peaks by calling addMarkerFeatures()
markersGenesCondition <- getMarkerFeatures(
    ArchRProj = projMulti4, 
    useMatrix = "GeneExpressionMatrix", #"PeakMatrix", 
    groupBy = "Conditions", #in CellColData
    bias = c("TSSEnrichment", 
             "log10(nFrags)", 
             "log10(Gex_nUMI)"), 
    testMethod = "wilcoxon",
    useGroups = "CF", #cell type 1
    bgdGroups = "CG" #cell type 2
)
```

```{r}
#plot Volcano
pv <- plotMarkers(
    seMarker = markersGenesCondition,
    name = "CF", #change cell type
    cutOff = "(FDR <= 0.001) & (Log2FC >= 1 | Log2FC <= 1)",#"FDR <= 0.1 & abs(Log2FC) >= 0.5",
    plotAs = "Volcano")
pv
```


```{r}
#save plots
plotPDF(pv, name = "Conditions-GeneExpression-Volcano", width = 5, height = 5, ArchRProj = projMulti4, addDOC = FALSE)
rm(pv)
```


## Motif and Feature Enrichment (point 12 in manual)

Want to predict what transcription factors may be mediating the binding events that create those accessible chromatin sites.

Can look for motifs that are enriched in peaks that are up or down regulated in various cell types.

- add these motif annotations to our project
it creates a binary matrix where the presence of a motif in each peak is indicated numerically

### Motif Enrichment in Differential Peaks

```{r}
#| message: false
#| warning: false

#add information about which peaks contain motifs
projMulti4 <- addMotifAnnotations(
    ArchRProj = projMulti4, 
    motifSet = "cisbp", 
    name = "Motif",
    force = T)
```


We can then use the differential testing SummarizedExperiment object markerTest which was generated in the previous chapter to define the set of significantly differential peaks that we are interested in testing for motif enrichment.

```{r}
#| message: false
#| warning: false

#based on the markerTest from previous analysis or the entire markerPeaks
motifsUp <- peakAnnoEnrichment(
    seMarker = markersPeaks, #markerTest,
    ArchRProj = projMulti4,
    peakAnnotation = "Motif",
    cutOff = "FDR <= 0.5 & Log2FC >= 0.5"
  )

#motifs enrichment from differential testing among conditions
motifsUpCondition <- peakAnnoEnrichment(
    seMarker = markersPeaksCondition, #markerTest,
    ArchRProj = projMulti4,
    peakAnnotation = "Motif",
    cutOff = "FDR <= 0.5 & Log2FC >= 0.5"
  )

motifsUp_Cholinergic <- peakAnnoEnrichment(
    seMarker = marker_Cholinergic, #markerTest,
    ArchRProj = projMulti4,
    peakAnnotation = "Motif",
    cutOff = "FDR <= 0.5 & Log2FC >= 0.5"
  )

motifsUp_Oligodendrocytes <- peakAnnoEnrichment(
    seMarker = marker_Oligodendrocytes, #markerTest,
    ArchRProj = projMulti4,
    peakAnnotation = "Motif",
    cutOff = "FDR <= 0.5 & Log2FC >= 0.5"
  )

#based on the markerTest from previous analysis or the entire markerPeaks
motifsDown <- peakAnnoEnrichment(
    seMarker = markersPeaks, #markerTest,
    ArchRProj = projMulti4,
    peakAnnotation = "Motif",
    cutOff = "FDR <= 0.1 & Log2FC <= -0.5"
  )

#motifs enrichment from differential testing among conditions
motifsDownCondition <- peakAnnoEnrichment(
    seMarker = markersPeaksCondition, #markerTest,
    ArchRProj = projMulti4,
    peakAnnotation = "Motif",
    cutOff = "FDR <= 0.1 & Log2FC <= -0.5"
  )

motifsDown_Cholinergic <- peakAnnoEnrichment(
    seMarker = marker_Cholinergic, #markerTest,
    ArchRProj = projMulti4,
    peakAnnotation = "Motif",
    cutOff = "FDR <= 0.1 & Log2FC <= -0.5"
  )

motifsDown_Oligodendrocytes <- peakAnnoEnrichment(
    seMarker = marker_Oligodendrocytes, #markerTest,
    ArchRProj = projMulti4,
    peakAnnotation = "Motif",
    cutOff = "FDR <= 0.1 & Log2FC <= -0.5"
  )
```

### Motifs up among every cells
#### CF
```{r}
#To prepare this data for plotting with ggplot we can create a simplified data.frame object containing the motif names, the corrected p-values, and the significance rank
df_CF <- data.frame(TF = rownames(motifsUp), mlog10Padj = assay(motifsUp)[,1])
df_CF <- df_CF[order(df_CF$mlog10Padj, decreasing = TRUE),]
df_CF$rank <- seq_len(nrow(df_CF))
```

```{r}
#to test the most enriched motifs in the peaks 
head(df_CF)
```

#### CG
```{r}
#To prepare this data for plotting with ggplot we can create a simplified data.frame object containing the motif names, the corrected p-values, and the significance rank
df_CG <- data.frame(TF = rownames(motifsDown), mlog10Padj = assay(motifsDown)[,1])
df_CG <- df_CG[order(df_CG$mlog10Padj, decreasing = TRUE),]
df_CG$rank <- seq_len(nrow(df_CG))
```

```{r}
#to test the most enriched motifs in the peaks 
head(df_CG)
```


### Motifs up among conditions
#### CF
```{r}
#To prepare this data for plotting with ggplot we can create a simplified data.frame object containing the motif names, the corrected p-values, and the significance rank
df_cond_CF <- data.frame(TF = rownames(motifsUpCondition), mlog10Padj = assay(motifsUpCondition)[,1])
df_cond_CF <- df_cond_CF[order(df_cond_CF$mlog10Padj, decreasing = TRUE),]
df_cond_CF$rank <- seq_len(nrow(df_cond_CF))
```

```{r}
#to test the most enriched motifs in the peaks 
head(df_cond_CF)
```

#### CG
```{r}
#To prepare this data for plotting with ggplot we can create a simplified data.frame object containing the motif names, the corrected p-values, and the significance rank
df_cond_CG <- data.frame(TF = rownames(motifsDownCondition), mlog10Padj = assay(motifsDownCondition)[,1])
df_cond_CG <- df_cond_CG[order(df_cond_CG$mlog10Padj, decreasing = TRUE),]
df_cond_CG$rank <- seq_len(nrow(df_cond_CG))
```

```{r}
#to test the most enriched motifs in the peaks 
head(df_cond_CG)
```


### Motifs up in Cholinergic cells
#### CF
```{r}
#To prepare this data for plotting with ggplot we can create a simplified data.frame object containing the motif names, the corrected p-values, and the significance rank
df_Cholinergic_CF <- data.frame(TF = rownames(motifsUp_Cholinergic), mlog10Padj = assay(motifsUp_Cholinergic)[,1])
df_Cholinergic_CF <- df_Cholinergic_CF[order(df_Cholinergic_CF$mlog10Padj, decreasing = TRUE),]
df_Cholinergic_CF$rank <- seq_len(nrow(df_Cholinergic_CF))
```

```{r}
#to test the most enriched motifs in the peaks 
head(df_Cholinergic_CF)
```

#### CG
```{r}
#To prepare this data for plotting with ggplot we can create a simplified data.frame object containing the motif names, the corrected p-values, and the significance rank
df_Cholinergic_CG <- data.frame(TF = rownames(motifsDown_Cholinergic), mlog10Padj = assay(motifsDown_Cholinergic)[,1])
df_Cholinergic_CG <- df_Cholinergic_CG[order(df_Cholinergic_CG$mlog10Padj, decreasing = TRUE),]
df_Cholinergic_CG$rank <- seq_len(nrow(df_Cholinergic_CG))
```

```{r}
#to test the most enriched motifs in the peaks 
head(df_Cholinergic_CG)
```


### Motifs up in Oligodendrocytes
#### CF
```{r}
#To prepare this data for plotting with ggplot we can create a simplified data.frame object containing the motif names, the corrected p-values, and the significance rank
df_Oligodendrocytes_CF <- data.frame(TF = rownames(motifsUp_Oligodendrocytes), mlog10Padj = assay(motifsUp_Oligodendrocytes)[,1])
df_Oligodendrocytes_CF <- df_Oligodendrocytes_CF[order(df_Oligodendrocytes_CF$mlog10Padj, decreasing = TRUE),]
df_Oligodendrocytes_CF$rank <- seq_len(nrow(df_Oligodendrocytes_CF))
```

```{r}
#to test the most enriched motifs in the peaks 
head(df_Oligodendrocytes_CF)
```

#### CG
```{r}
#To prepare this data for plotting with ggplot we can create a simplified data.frame object containing the motif names, the corrected p-values, and the significance rank
df_Oligodendrocytes_CG <- data.frame(TF = rownames(motifsDown_Oligodendrocytes), mlog10Padj = assay(motifsDown_Oligodendrocytes)[,1])
df_Oligodendrocytes_CG <- df_Oligodendrocytes_CG[order(df_Oligodendrocytes_CG$mlog10Padj, decreasing = TRUE),]
df_Oligodendrocytes_CG$rank <- seq_len(nrow(df_Oligodendrocytes_CG))
```

```{r}
#to test the most enriched motifs in the peaks 
head(df_Oligodendrocytes_CG)
```




```{r}
# NOTE: if only very few marker on the graph, run "options(ggrepel.max.overlaps = Inf)" in the console before hand.
options(ggrepel.max.overlaps = Inf)
```


```{r}
#Using ggplot we can plot the rank-sorted TF motifs and color them by the significance of their enrichment. Here we use ggrepel to label each TF motif.
ggUp_CF <- ggplot(df_CF, aes(rank, mlog10Padj, color = mlog10Padj)) + 
  geom_point(size = 1) +
  ggrepel::geom_label_repel(
        data = df_CF[rev(seq_len(30)), ], aes(x = rank, y = mlog10Padj, label = TF), 
        size = 1.5,
        nudge_x = 2,
        color = "black",

  ) + theme_ArchR() + 
  ylab("-log10(P-adj) Motif Enrichment") + 
  xlab("Rank Sorted TFs Enriched") +
  scale_color_gradientn(colors = paletteContinuous(set = "comet")) +
    ggtitle("Motif enrichment among every cells in CF")

ggUp_CF
```

```{r}
#Using ggplot we can plot the rank-sorted TF motifs and color them by the significance of their enrichment. Here we use ggrepel to label each TF motif.
ggUp_CG <- ggplot(df_CG, aes(rank, mlog10Padj, color = mlog10Padj)) + 
  geom_point(size = 1) +
  ggrepel::geom_label_repel(
        data = df_CG[rev(seq_len(30)), ], aes(x = rank, y = mlog10Padj, label = TF), 
        size = 1.5,
        nudge_x = 2,
        color = "black",

  ) + theme_ArchR() + 
  ylab("-log10(P-adj) Motif Enrichment") + 
  xlab("Rank Sorted TFs Enriched") +
  scale_color_gradientn(colors = paletteContinuous(set = "comet")) +
    ggtitle("Motif enrichment among every cells in CG")

ggUp_CG
```


```{r}
#Using ggplot we can plot the rank-sorted TF motifs and color them by the significance of their enrichment. Here we use ggrepel to label each TF motif.
ggUp_cond_CF <- ggplot(df_cond_CF, aes(rank, mlog10Padj, color = mlog10Padj)) + 
  geom_point(size = 1) +
  ggrepel::geom_label_repel(
        data = df_cond_CF[rev(seq_len(30)), ], aes(x = rank, y = mlog10Padj, label = TF), 
        size = 1.5,
        nudge_x = 2,
        color = "black",

  ) + theme_ArchR() + 
  ylab("-log10(P-adj) Motif Enrichment") + 
  xlab("Rank Sorted TFs Enriched") +
  scale_color_gradientn(colors = paletteContinuous(set = "comet")) +
    ggtitle("Motif enrichment in CF")

ggUp_cond_CF
```


```{r}
#Using ggplot we can plot the rank-sorted TF motifs and color them by the significance of their enrichment. Here we use ggrepel to label each TF motif.
ggUp_cond_CG <- ggplot(df_cond_CG, aes(rank, mlog10Padj, color = mlog10Padj)) + 
  geom_point(size = 1) +
  ggrepel::geom_label_repel(
        data = df_cond_CG[rev(seq_len(30)), ], aes(x = rank, y = mlog10Padj, label = TF), 
        size = 1.5,
        nudge_x = 2,
        color = "black",

  ) + theme_ArchR() + 
  ylab("-log10(P-adj) Motif Enrichment") + 
  xlab("Rank Sorted TFs Enriched") +
  scale_color_gradientn(colors = paletteContinuous(set = "comet")) +
    ggtitle("Motif enrichment in CG")

ggUp_cond_CG
```


```{r}
#Using ggplot we can plot the rank-sorted TF motifs and color them by the significance of their enrichment. Here we use ggrepel to label each TF motif.
ggUp_Cholinergic_CF <- ggplot(df_Cholinergic_CF, aes(rank, mlog10Padj, color = mlog10Padj)) + 
  geom_point(size = 1) +
  ggrepel::geom_label_repel(
        data = df_Cholinergic_CF[rev(seq_len(30)), ], aes(x = rank, y = mlog10Padj, label = TF), 
        size = 1.5,
        nudge_x = 2,
        color = "black",

  ) + theme_ArchR() + 
  ylab("-log10(P-adj) Motif Enrichment") + 
  xlab("Rank Sorted TFs Enriched") +
  scale_color_gradientn(colors = paletteContinuous(set = "comet")) +
    ggtitle("Motif enrichment in Cholinergic in CF")

ggUp_Cholinergic_CF
```


```{r}
#Using ggplot we can plot the rank-sorted TF motifs and color them by the significance of their enrichment. Here we use ggrepel to label each TF motif.
ggUp_Cholinergic_CG <- ggplot(df_Cholinergic_CG, aes(rank, mlog10Padj, color = mlog10Padj)) + 
  geom_point(size = 1) +
  ggrepel::geom_label_repel(
        data = df_Cholinergic_CG[rev(seq_len(30)), ], aes(x = rank, y = mlog10Padj, label = TF), 
        size = 1.5,
        nudge_x = 2,
        color = "black",

  ) + theme_ArchR() + 
  ylab("-log10(P-adj) Motif Enrichment") + 
  xlab("Rank Sorted TFs Enriched") +
  scale_color_gradientn(colors = paletteContinuous(set = "comet")) +
    ggtitle("Motif enrichment in Cholinergic in CG")

ggUp_Cholinergic_CG
```


```{r}
#Using ggplot we can plot the rank-sorted TF motifs and color them by the significance of their enrichment. Here we use ggrepel to label each TF motif.
ggUp_Oligodendrocytes_CF <- ggplot(df_Oligodendrocytes_CF, aes(rank, mlog10Padj, color = mlog10Padj)) + 
  geom_point(size = 1) +
  ggrepel::geom_label_repel(
        data = df_Oligodendrocytes_CF[rev(seq_len(30)), ], aes(x = rank, y = mlog10Padj, label = TF), 
        size = 1.5,
        nudge_x = 2,
        color = "black",

  ) + theme_ArchR() + 
  ylab("-log10(P-adj) Motif Enrichment") + 
  xlab("Rank Sorted TFs Enriched") +
  scale_color_gradientn(colors = paletteContinuous(set = "comet")) +
    ggtitle("Motif enrichment in Oligodendrocytes in CF")

ggUp_Oligodendrocytes_CF
```


```{r}
#Using ggplot we can plot the rank-sorted TF motifs and color them by the significance of their enrichment. Here we use ggrepel to label each TF motif.
ggUp_Oligodendrocytes_CG <- ggplot(df_Oligodendrocytes_CG, aes(rank, mlog10Padj, color = mlog10Padj)) + 
  geom_point(size = 1) +
  ggrepel::geom_label_repel(
        data = df_Oligodendrocytes_CG[rev(seq_len(30)), ], aes(x = rank, y = mlog10Padj, label = TF), 
        size = 1.5,
        nudge_x = 2,
        color = "black",

  ) + theme_ArchR() + 
  ylab("-log10(P-adj) Motif Enrichment") + 
  xlab("Rank Sorted TFs Enriched") +
  scale_color_gradientn(colors = paletteContinuous(set = "comet")) +
    ggtitle("Motif enrichment in Oligodendrocytes in CG")

ggUp_Oligodendrocytes_CG
```

```{r}
#save plots
plotPDF(ggUp_CF, ggUp_CG, ggUp_cond_CF, ggUp_cond_CG, ggUp_Cholinergic_CF, ggUp_Cholinergic_CG, ggUp_Oligodendrocytes_CF, ggUp_Oligodendrocytes_CG, name = "Motifs-Enriched-plot", width = 5, height = 5, ArchRProj = projMulti4, addDOC = FALSE)
rm(ggUp_CF, ggUp_CG, ggUp_cond_CF, ggUp_cond_CG, ggUp_Cholinergic_CF, ggUp_Cholinergic_CG, ggUp_Oligodendrocytes_CF, ggUp_Oligodendrocytes_CG)
```



### Motif Enrichment in Marker Peaks

Can also perform motif enrichment on our marker peaks identified in using getMarkerFeatures()

```{r}
#| message: false
#| warning: false

enrichMotifs <- peakAnnoEnrichment(
    seMarker = markersPeaks,
    ArchRProj = projMulti4,
    peakAnnotation = "Motif",
    cutOff = "FDR <= 0.1 & Log2FC >= 0.5"
  )
```


```{r}
#plot motif enrichments across all cell groups
heatmapEM <- plotEnrichHeatmap(enrichMotifs, 
                               n = 7, #number of motifs shown per cell group
                               transpose = TRUE)
```


```{r}
#plot
#ComplexHeatmap::draw(heatmapEM, heatmap_legend_side = "bot", annotation_legend_side = "bot")
```


```{r}
#save plot
plotPDF(heatmapEM, name = "Motifs-Enriched-Marker-Heatmap", width = 8, height = 6, ArchRProj = projMulti4, addDOC = FALSE)
rm(heatmapEM)
```


### ArchR Enrichment
Can use other collections in order to identify enrichment motifs

- Encode
- Bulk ATAC-seq
- Codex
(check ArchR_multi_complete script for the corresponding code)


## ChromVAR Deviations Enrichment (point 13 in manual)

Here allow a per-cell basis enrichment count.
chromVAR also account for Tn5 transposases insertion bias !!!

ArchR uses chromVAR:
- reads in the global accessibility per peak across all cells in each sub-samples
- For each peak, identifies a set of background peaks that are matched by GC-content and accessibility
- uses this background set of peaks and global accessibility to compute bias-corrected deviations with chromVAR for each sample independently


### Motif Deviations

```{r}
#make sure we have added motif annotations to the project
## if motif not in names(projMulti4@peakAnnotation), then add it
if("Motif" %ni% names(projMulti4@peakAnnotation)){
    projMulti4 <- addMotifAnnotations(ArchRProj = projMulti4, motifSet = "cisbp", name = "Motif")
}
```


```{r}
#add set of background peaks
projMulti4 <- addBgdPeaks(projMulti4)
```


```{r}
#| message: false
#| warning: false

#compute per-cell deviations across all of our motif annotations
#create a deviations matrix in each of our Arrow files called "MotifMatrix"
projMulti4 <- addDeviationsMatrix(
  ArchRProj = projMulti4, 
  peakAnnotation = "Motif",
  force = TRUE
)
```


```{r}
#to access those deivations
plotVarDev <- getVarDeviations(projMulti4, name = "MotifMatrix", plot = TRUE)
```


```{r}
#plot
#plotVarDev
```


```{r}
#save plot
plotPDF(plotVarDev, name = "Variable-Motif-Deviation-Scores", width = 5, height = 5, ArchRProj = projMulti4, addDOC = FALSE)
rm(plotVarDev)
```


#### Analyze variability of a subset of features

```{r}
#to analyze subset of features
# motifs <- c() #instead of using "my_markers" you can specify another list here
motifs <- my_markers
markerMotifs <- getFeatures(projMulti4, select = paste(motifs, collapse="|"), useMatrix = "MotifMatrix")
markerMotifs
```


```{r}
#want to remove a specific marker
markerMotifs <- grep("z:", markerMotifs, value = TRUE) #keeps only z-values
markerMotifs <- markerMotifs[markerMotifs %ni% "z:SREBF1_22"] #remove this specific marker
markerMotifs
```


```{r}
#| message: false
#| warning: false

#plot the distribution of chromVAR deviation scores for each cluster
#Notice that we supply the impute weights that we calculated previously during our gene score analyses
#these impute weights allow us to smooth the signal across nearby cells which is helpful in the context of our sparse scATAC-seq data

p <- plotGroups(ArchRProj = projMulti4, 
  groupBy = "predictedGroup_Un_3", #"Conditions", 
  colorBy = "MotifMatrix", 
  name = markerMotifs,
  imputeWeights = getImputeWeights(projMulti4)
)
```


```{r}
#cowplot to plot the distributions of all motifs in a single plot
p2 <- lapply(seq_along(p), function(x){
  if(x != 1){
    p[[x]] + guides(color = "none", fill = "none") + 
    theme_ArchR(baseSize = 6) +
    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")) +
    theme(
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank(),
        axis.title.y=element_blank()
    ) + ylab("")
  }else{
    p[[x]] + guides(color = "none", fill = "none") + 
    theme_ArchR(baseSize = 6) +
    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")) +
    theme(
        axis.ticks.y=element_blank(),
        axis.title.y=element_blank()
    ) + ylab("")
  }
})
#do.call(cowplot::plot_grid, c(list(nrow = 1, rel_widths = c(2, rep(1, length(p2) - 1))),p2))
```


```{r}
#save plot
plotPDF(p, name = "Plot-Groups-Deviations-w-Imputation", width = 5, height = 5, ArchRProj = projMulti4, addDOC = FALSE)
rm(p)
```


#### Overlay z-scores on UMAP

```{r}
#overlay the z-scores on our UMAP embedding as we've done previously for gene scores
p <- plotEmbedding(
    ArchRProj = projMulti4, 
    colorBy = "MotifMatrix", 
    name = sort(markerMotifs), 
    embedding = "UMAPHarmony", #can change embedding here
    imputeWeights = getImputeWeights(projMulti4)
)
```


```{r}
#| warning: false

#can plot all of these motif UMAPs using cowplot
p2 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
#do.call(cowplot::plot_grid, c(list(ncol = 3),p2))
```


```{r}
#save plot
plotPDF(p, name = "Plot-Groups-Deviations-w-Z-score-embedding", width = 5, height = 5, ArchRProj = projMulti4, addDOC = FALSE)
rm(p)
```


#### Overlay Gene Expression 

To see how these TF deviation z-scores compare to the inferred gene expression via gene scores of the corresponding TF genes, we can overlay the gene scores for each of these TFs on the UMAP embedding.


```{r}
markerRNA <- getFeatures(projMulti4, 
                         select = paste(motifs, collapse="|"), 
                         useMatrix = "GeneExpressionMatrix")
markerRNA <- markerRNA[markerRNA %ni% c("Chic1","Egfros", "Gba2", "Kptn", "Nptn", "Optn", "Ppargc1a", "Ppargc1b","Prox1os", "Qsox2", "Rptn", "Sox2ot", "Spink1", "Spink10", "Spink11", "Spink12", "Spink13", "Spink14", "Sox6os", "Sox21", "Uchl1os", "Vps35l")] #exclude some motifs that are not in "my_markers"
sort(markerRNA)
#sort(my_markers) #to compare if needed
```


```{r}
p <- plotEmbedding(
    ArchRProj = projMulti4, 
    colorBy = "GeneExpressionMatrix", 
    name = sort(markerRNA), 
    embedding = "UMAPHarmony",
    imputeWeights = getImputeWeights(projMulti4)
)
```


```{r}
#cowplot to plot single features
p2 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) + 
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()
    )
})
#do.call(cowplot::plot_grid, c(list(ncol = 3),p2))
```


```{r}
#save plot
plotPDF(p, name = "Plot-Groups-Deviations-w-GeneExpression-embedding", width = 5, height = 5, ArchRProj = projMulti4, addDOC = FALSE)
rm(p)
```


#### Overlay Linked gene expression (ATAC + RNA)

Similarly, because we previously linked our scATAC-seq data with corresponding scRNA-seq data, we can plot the linked gene expression for each of these TFs on the UMAP embedding.

```{r}
getAvailableMatrices(projMulti4)
```


```{r}
markerRNA <- getFeatures(projMulti4,
                         select = paste(motifs, collapse="|"),
                         useMatrix = "GeneIntegrationMatrix_db_3")

markerRNA <- markerRNA <- markerRNA[markerRNA %ni% c("Chic1","Egfros", "Gba2", "Kptn", "Nptn", "Optn", "Ppargc1a", "Ppargc1b","Prox1os", "Qsox2", "Rptn", "Sox2ot", "Spink1", "Spink10", "Spink11", "Spink12", "Spink13", "Spink14", "Sox6os", "Sox21", "Uchl1os", "Vps35l")] #exclude some motifs that are not in "my_markers"
markerRNA
```


```{r}
p <- plotEmbedding(
    ArchRProj = projMulti4,
    colorBy = "GeneIntegrationMatrix_db_3",
    name = sort(markerRNA),
    embedding = "UMAPHarmony",
    continuousSet = "blueYellow",
    imputeWeights = getImputeWeights(projMulti4)
)
```


```{r}
#| warning: false
p2 <- lapply(p, function(x){
    x + guides(color = FALSE, fill = FALSE) +
    theme_ArchR(baseSize = 6.5) +
    theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
    theme(
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank()
    )
})
#do.call(cowplot::plot_grid, c(list(ncol = 3),p2))
```

```{r}
#to save
plotPDF(plotList = p, 
    name = "linked-gene-expression-of-TF.pdf", 
    ArchRProj = projMulti4, 
    addDOC = FALSE, width = 5, height = 5)
rm(p)
```


### Also custom Deviations (point 13.2 in manual)
Check ArchR_multi_complete for the code for it


## Footprinting (point 14 in manual)

Transcription factors (TF) footprinting allows for the prediction of the precise binding location of a TF at a particular locus.


### Motif Footprint

```{r}
#create a GRangesList
motifPositions <- getPositions(projMulti4)
```


```{r}
motifPositions
```


```{r}
#list of marker to use for the subset
# motifs <- c() #specify another motifs list here if want others than my_markers
motifs <- c(my_markers, "Zfp148", "Tcf15", "Scx")

markerMotifs <- unlist(lapply(motifs, function(x) grep(x, names(motifPositions), value = TRUE)))
markerMotifs <- markerMotifs[markerMotifs %ni% "SREBF1_22"]
markerMotifs
```


```{r}
#| message: false
#| warning: false

projMulti4 <- addGroupCoverages(ArchRProj = projMulti4,
                                groupBy = "predictedGroup_Un_3")
```


```{r}
#compute footprints for the subset of marker motifs that we previously selected using the getFootprints() function
#recommended to perform footprinting on a subset of motifs rather than all motifs
#provide the subset of motifs to footprint via the positions parameter
seFoot <- getFootprints(
  ArchRProj = projMulti4, 
  positions = motifPositions[markerMotifs], #specify the subset of motifs
  groupBy = "predictedGroup_Un_3"
)
```


Once we have retrieved these footprints, we can plot them using the plotFootprints() function.

### Normalization of Footprints for Tn5 Bias
Normalization of the bias

#### Substracting the Tn5 Bias

```{r}
#plot footprints
plotFootprints(
  seFoot = seFoot,
  ArchRProj = projMulti4, 
  normMethod = "Subtract",
  plotName = "Footprints-Subtract-Bias",
  addDOC = FALSE,
  smoothWindow = 5
)
```


#### Dividing by the Tn5 Bias
Second strategy for normalization

```{r}
#other strategy to normalize: divide footprint signal by the Tn5 bias signal
plotFootprints(
  seFoot = seFoot,
  ArchRProj = projMulti4, 
  normMethod = "Divide",
  plotName = "Footprints-Divide-Bias",
  addDOC = FALSE,
  smoothWindow = 5
)
```


#### Footprinting Without Normalization for Tn5 Bias
Normalization is highly recommended but it is possible to plot the footprints without normalization.

```{r}
#no normalization
plotFootprints(
  seFoot = seFoot,
  ArchRProj = projMulti4, 
  normMethod = "None", #says that no normalization is performed
  plotName = "Footprints-No-Normalization",
  addDOC = FALSE,
  smoothWindow = 5
)
```


### Feature Footprinting
Footprinting of any user-defined feature set

Here, TSS (Transcription Start Site) insertion profile (= specialized subcase of footprinting)


```{r}
#create TSS insertion profiles without normalization for Tn5 bias
#main difference from our previous analyses is that we specify flank = 2000 to extend these footprints 2000 bp on either side of each TSS
seTSS <- getFootprints(
  ArchRProj = projMulti4, 
  positions = GRangesList(TSS = getTSS(projMulti4)), #specify 
  groupBy = "predictedGroup_Un_3",
  flank = 2000 #extend the footprints on both side of each TSS
)
```


```{r}
#plot 
plotFootprints(
  seFoot = seTSS,
  ArchRProj = projMulti4, 
  normMethod = "None",
  plotName = "TSS-No-Normalization",
  addDOC = FALSE,
  flank = 2000,
  flankNorm = 100
)
```


## Integrative Analysis (point 15 in manual)
Deeper insights !!!

Strength of ArchR is the ability to integrate multiple levels of information to provide novel insights (either ATAC-seq only or analysis integrating scRNA-seq data).


### Creating Low-Overlapping Aggregates of Cells (Cicero)

ArchR facilitates many integrative analyses that involve correlation of features.
With sparse single-cell data, can lead to substantial noise in these correlative analyses.

Here, uses **Cicero** to filter out aggregate with more than 80% overlap.


### Co-accessibility with ArchR

Co-accessibility is a correlation in accessibility between 2 peaks across many single cells.

```{r}
#add co-accessibility peaks to the object
projMulti4 <- addCoAccessibility(
    ArchRProj = projMulti4,
    reducedDims = "Harmony" #can change dimensionality reduction here
)
```


```{r}
#retrieve the co-accessibility information
cA <- getCoAccessibility(
    ArchRProj = projMulti4,
    corCutOff = 0.5,
    resolution = 1,
    returnLoops = FALSE #returns dataframe only when = FALSE
)
```


```{r}
cA
```


This co-accessibility DataFrame also has a metadata component containing a GRanges object of the relevant peaks. The indexes of queryHits and subjectHits mentioned above apply to this GRanges object.

```{r}
metadata(cA)[[1]]
```


```{r}
#resolution = 1 creates loops that connect the center of each peak
cA <- getCoAccessibility(
    ArchRProj = projMulti4,
    corCutOff = 0.5,
    resolution = 1, #when decrease the resolution (= 1000 instead of = 1), can help with overplotting of co-accessibility interactions
    returnLoops = TRUE # return co-accessibility in the form of a loop track
)
```


```{r}
cA[[1]]
```


#### Plotting browser tracks of Co-accessibility

Can plot on the browser a list of our markerGenes

```{r}
# markerGenes <- c()
markerGenes <- my_markers

p <- plotBrowserTrack(
    ArchRProj = projMulti4, 
    groupBy = "predictedGroup_Un_3", 
    geneSymbol = "Dkk3", #my_markers, #markerGenes, 
    upstream = 50000,
    downstream = 50000,
    loops = getCoAccessibility(projMulti4)
)
```


```{r}
#to open in browser
# grid::grid.newpage()
# grid::grid.draw(p$Dkk3)
```


```{r}
#to save
plotPDF(plotList = p, 
    name = "Plot-Tracks-Marker-Genes-with-CoAccessibility.pdf", 
    ArchRProj = projMulti4, 
    addDOC = FALSE, width = 5, height = 5)
rm(p)
```


### Peak2GeneLinkage (point 15.3 in manual)

Identify "peak to gene links" (done in chapter ("Calling Peaks (point 9 & 10 in manual)") above). Here we will call: 

**co-accessibility = ATAC-seq-only analysis**
**Peak2GeneLinkage = leverages scRNA-seq data to look for correlations between peak accessibility and gene expression**

--> correlates scATAC-seq and scRNA-seq: often think of these links as more relevant to gene regulatory interactions.


#### Plotting browser tracks with peak-to-gene links

```{r}
# markerGenes <- c()

p <- plotBrowserTrack(
    ArchRProj = projMulti4, 
    groupBy = "predictedGroup_Un_3", 
    geneSymbol = markerGenes, 
    upstream = 50000,
    downstream = 50000,
    loops = getPeak2GeneLinks(projMulti4) #the links were stored in projMulti4
)
```


```{r}
#plot browser track
grid::grid.newpage()
grid::grid.draw(p$Dkk3)
```


```{r}
#| message: false
#| warning: false

#save plots
plotPDF(plotList = p, 
    name = "Plot-Tracks-Marker-Genes-with-Peak2GeneLinks.pdf", 
    ArchRProj = projMulti4, 
    addDOC = FALSE, width = 5, height = 5)
rm(p)
```


#### Plotting a heatmap of peak-to-gene links

To visualize the correspondence of all of our **peak-to-gene links**, we can plot a peak-to-gene **heatmap** which contains two side-by-side heatmaps:

- one for our scATAC-seq data
- one for our scRNA-seq data

```{r}
#| message: false
#| warning: false

p <- plotPeak2GeneHeatmap(ArchRProj = projMulti4, 
                          groupBy = "predictedGroup_Un_3")
```


The heatmap rows are clustered using k-means clustering based on the value passed to the parameter k, which defaults to 25 as shown below.


```{r}
#| message: false
#| warning: false

#save plot
plotPDF(p, 
        name = "Heatmap-coaccessibility-ATAC-RNA.pdf", 
        ArchRProj = projMulti4, 
        addDOC = FALSE,
        height = 10,
        width = 15)
rm(p)
```


### Identification of Positive TF-Regulators (point 15.4 in manual)

- When **RNA-seq not available** in the experiment: use chromVAR deviation z-scores of TF motifs (using "Gene activity matrix")
or
- When **RNA-seq available** in the experiment: use scRNA-seq gene expression of the TF

#### Step1. Identify Deviant TF Motifs
Did that when creating "MotifMatrix"

```{r}
#| message: false
#| warning: false

#retrieve this data (deviant TF motifs)
seGroupMotif <- getGroupSE(ArchRProj = projMulti4, 
                           useMatrix = "MotifMatrix", 
                           groupBy = "predictedGroup_Un_3")
```


```{r}
#since it comes from MotifMatrix, has "deviations" & "z" corresponding to row and z-score deviations
seGroupMotif
```


```{r}
#subset this SummarizedExperiment to just the "deviation z-scores"
seZ <- seGroupMotif[rowData(seGroupMotif)$seqnames=="z",]
```


```{r}
#identify the maximum delta in z-score between all clusters
#will be helpful in stratifying motifs based on the degree of variation observed across clusters
rowData(seZ)$maxDelta <- lapply(seq_len(ncol(seZ)), function(x){
  rowMaxs(assay(seZ) - assay(seZ)[,x])
}) %>% Reduce("cbind", .) %>% rowMaxs
```


#### Step2. Identify Correlated TF Motifs and TF Gene Score/Expression

To identify TFs whose motif accessibility is correlated with their own gene activity (either by gene score or gene expression), we use the correlateMatrices() function and provide the **two matrices that we are interested in, in this case the GeneScoreMatrix and the MotifMatrix**.

correlations are determined across many low-overlapping cell aggregates determined in the lower dimension space specified in the reducedDims parameter

```{r}
corGSM_MM <- correlateMatrices(
    ArchRProj = projMulti4,
    useMatrix1 = "GeneExpressionMatrix",
    useMatrix2 = "MotifMatrix",
    reducedDims = "Harmony"
)
```


```{r}
#look at the dataframe
corGSM_MM
```


Same analysis with the GeneIntegrationMatrix:

```{r}
#can perform the same analysis using the GeneIntegrationMatrix instead of the GeneScoreMatrix
corGIM_MM <- correlateMatrices(
    ArchRProj = projMulti4,
    useMatrix1 = "GeneIntegrationMatrix_db_3", #do we have that in our case?
    useMatrix2 = "MotifMatrix",
    reducedDims = "Harmony"
)
```


```{r}
corGIM_MM
```


#### Step3. Add Maximum Delta Deviation to the Correlation Data Frame

For each of these correlation analyses, we can annotate each motif with the maximum delta observed between clusters which we calculated in Step 1.

```{r}
corGSM_MM$maxDelta <- rowData(seZ)[match(corGSM_MM$MotifMatrix_name, rowData(seZ)$name), "maxDelta"]
corGIM_MM$maxDelta <- rowData(seZ)[match(corGIM_MM$MotifMatrix_name, rowData(seZ)$name), "maxDelta"]
```


#### Step4. Identify Positive TF Regulators

Can use all of this information to identify positive TF regulators

consider positive regulators as those TFs whose correlation between motif and gene score (or gene expression) is greater than 0.5 with an adjusted p-value less than 0.01 and a maximum inter-cluster difference in deviation z-score that is in the top quartile.

```{r}
corGSM_MM <- corGSM_MM[order(abs(corGSM_MM$cor), decreasing = TRUE), ]
corGSM_MM <- corGSM_MM[which(!duplicated(gsub("\\-.*","",corGSM_MM[,"MotifMatrix_name"]))), ]
corGSM_MM$TFRegulator <- "NO"
corGSM_MM$TFRegulator[which(corGSM_MM$cor > 0.5 & corGSM_MM$padj < 0.01 & corGSM_MM$maxDelta > quantile(corGSM_MM$maxDelta, 0.75))] <- "YES"
sort(corGSM_MM[corGSM_MM$TFRegulator=="YES",1])
```


```{r}
#plot the positive TF
p <- ggplot(data.frame(corGSM_MM), aes(cor, maxDelta, color = TFRegulator)) +
  geom_point() + 
  theme_ArchR() +
  geom_vline(xintercept = 0, lty = "dashed") + 
  scale_color_manual(values = c("NO"="darkgrey", "YES"="firebrick3")) +
  xlab("Correlation To Gene Score") +
  ylab("Max TF Motif Delta") +
  scale_y_continuous(
    expand = c(0,0), 
    limits = c(0, max(corGSM_MM$maxDelta)*1.05)
  )

p
```


```{r}
#same from the GeneIntegrationMatrix
corGIM_MM <- corGIM_MM[order(abs(corGIM_MM$cor), decreasing = TRUE), ]
corGIM_MM <- corGIM_MM[which(!duplicated(gsub("\\-.*","",corGIM_MM[,"MotifMatrix_name"]))), ]
corGIM_MM$TFRegulator <- "NO"
corGIM_MM$TFRegulator[which(corGIM_MM$cor > 0.5 & corGIM_MM$padj < 0.01 & corGIM_MM$maxDelta > quantile(corGIM_MM$maxDelta, 0.75))] <- "YES"
sort(corGIM_MM[corGIM_MM$TFRegulator=="YES",1])
```


```{r}
p <- ggplot(data.frame(corGIM_MM), aes(cor, maxDelta, color = TFRegulator)) +
  geom_point() + 
  theme_ArchR() +
  geom_vline(xintercept = 0, lty = "dashed") + 
  scale_color_manual(values = c("NO"="darkgrey", "YES"="firebrick3")) +
  xlab("Correlation To Gene Expression") +
  ylab("Max TF Motif Delta") +
  scale_y_continuous(
    expand = c(0,0), 
    limits = c(0, max(corGIM_MM$maxDelta)*1.05)
  )

p
```


## Trajectory Analysis with ArchR

To order cells in pseudo-time

ArchR creates cellular trajectories that order cells across a lower N-dimensional subspace within an ArchRProject.

--> Cellular trajectory tnat approximate the differentiation of pro-A to A.

```{r}
#review clusters and cell types that we defined and stored in cellColData in columns "Clusters" and "Clusters2"
p1 <- plotEmbedding(ArchRProj = projMulti4, 
                    colorBy = "cellColData", 
                    name = "Conditions", 
                    embedding = "UMAPHarmony")
```

```{r}
#in clusters2
p2 <- plotEmbedding(ArchRProj = projMulti4, 
                    colorBy = "cellColData", 
                    name = "predictedGroup_Un_3", 
                    embedding = "UMAPHarmony")
```

```{r}
ggAlignPlots(p1, p2, type = "h")
```


### Pseudo-time UMAPs and individual feature plots

create a vector of the form: c("cell_state_1", "cell_state_2", "cell_state_3")
from the definitions stored in "predictedGroup_Un_3"

```{r}
#print again every unique cell types in "predictedGroup_Un_3"
unique(projMulti4@cellColData@listData[["predictedGroup_Un_3"]])
```


```{r}
#define trajectory backbone of cell types to access
trajectory <- c("Oligodendrocytes", "Telencephalon projecting neurons")
trajectory
```


```{r}
#| message: false
#| warning: false

#add trajectory to project
#creates a new column in cellColData called "MyeloidU" (name = ...) that stores the pseudo-time value for each cell in the trajectory
projMulti4 <- addTrajectory(
    ArchRProj = projMulti4, 
    name = "Oligodendrocytes", #change name here if desired
    groupBy = "predictedGroup_Un_3",
    trajectory = trajectory, 
    embedding = "UMAPHarmony", 
    force = TRUE
)
```


```{r}
#look at this information (change value of name !!!) 
head(projMulti4$Oligodendrocytes[!is.na(projMulti4$Oligodendrocytes)])
```


```{r}
#plot
#function which overlays the pseudo-time values on our UMAP embedding and displays an arrow approximating the trajectory path from the spline-fit
p <- plotTrajectory(projMulti4, 
                    trajectory = "Oligodendrocytes", #change
                    colorBy = "cellColData", 
                    name = "Oligodendrocytes",
                    embedding = "UMAPHarmony") #change
```

```{r}
p[[1]]
```

```{r}
#save the plot
#change name accordingly
plotPDF(p, 
        name = "Plot-Oligodendrocytes-Traj-UMAP.pdf", 
        ArchRProj = projMulti4, 
        addDOC = FALSE, width = 5, height = 5)
rm(p)
```


#### Overlay other features

We can also overlay other features on the trajectory within our UMAP embedding. This allows us to display specific features only within the cells that are relevant to our trajectory.


```{r}
#Then, we can plot the "Oligodendrocytes" trajectory but color the cells by the gene score value of the CEBPB gene
#change trajectory, name
p1 <- plotTrajectory(projMulti4, 
                     trajectory = "Oligodendrocytes", 
                     colorBy = "GeneExpressionMatrix", 
                     name = "Kcnd2", #to color specific gene
                     continuousSet = "horizonExtra",
                     embedding = "UMAPHarmony")
```


```{r}
#We can repeat this process but color the cells by their linked gene expression via the GeneIntegrationMatrix
p2 <- plotTrajectory(projMulti4, 
                     trajectory = "Oligodendrocytes", 
                     colorBy = "GeneIntegrationMatrix_db_3", #can change matrix
                     name = "Kcnd2", 
                     continuousSet = "blueYellow",
                     embedding = "UMAPHarmony")
```


The plotTrajectory() function actually returns a list of relevant plots. The first plot in the list is a UMAP embedding, colorized as specified in the function call.

Comparing these UMAP plots side-by-side for the gene score and gene expression, we see that the activity of the CEBPB gene (gene of interest) is highly specific to a type of cells in the later part of the pseudo-time trajectory.


```{r}
p_umap_traj <- ggAlignPlots(p1[[1]], p2[[1]], type = "h")
```


The second plot that is returned by plotTrajectory() is a dot plot of pseudo-time versus the value of the relevant feature, in this case, the gene score or gene expression of the gene. In this case, the cells are colored by their pseudo-time.

```{r}
p_traj <- ggAlignPlots(p1[[2]], p2[[2]], type = "h")
```

```{r}
savePDF(p_umap_traj, p_traj, name = "trajectory-umap-pseudotime", ArchRProj = projMulti4)
```


###  Pseudo-time heatmaps

We can visualize changes in many features across pseudo-time using heatmaps. 

We will create these pseudo-time heatmaps for:
- motifs, 
- gene scores, 
- gene expression, 
- and peak accessibility 
by passing the corresponding matrix to the useMatrix parameter.

```{r}
#| message: false
#| warning: false

#pseudo-time for motifs
trajMM  <- getTrajectory(ArchRProj = projMulti4, 
                         name = "Oligodendrocytes", 
                         useMatrix = "MotifMatrix", 
                         log2Norm = FALSE)
```


```{r}
#| message: false
#| warning: false

p1 <- plotTrajectoryHeatmap(trajMM, pal = paletteContinuous(set = "solarExtra"))
```


```{r}
#| message: false
#| warning: false

#Pseudo-time for Gene Expression
trajGSM <- getTrajectory(ArchRProj = projMulti4, 
                         name = "Oligodendrocytes", 
                         useMatrix = "GeneExpressionMatrix", 
                         log2Norm = TRUE)
```


```{r}
#| message: false
#| warning: false

p2 <- plotTrajectoryHeatmap(trajGSM,  pal = paletteContinuous(set = "horizonExtra"))
```


```{r}
#| message: false
#| warning: false

#PSeudo-time for Gene Integration
trajGIM <- getTrajectory(ArchRProj = projMulti4, 
                         name = "Oligodendrocytes", 
                         useMatrix = "GeneIntegrationMatrix_db_3", 
                         log2Norm = FALSE)
```


```{r}
#| message: false
#| warning: false

p3 <- plotTrajectoryHeatmap(trajGIM,  pal = paletteContinuous(set = "blueYellow"))
```


```{r}
#| message: false
#| warning: false

#pseudo-time for "PeakMatrix"
trajPM  <- getTrajectory(ArchRProj = projMulti4, 
                         name = "Oligodendrocytes", 
                         useMatrix = "PeakMatrix", 
                         log2Norm = TRUE)
```


```{r}
#| message: false
#| warning: false

p4 <- plotTrajectoryHeatmap(trajPM, pal = paletteContinuous(set = "solarExtra"))
```


```{r}
#save plots
plotPDF(p1, p2, p3, p4, 
        name = "Plot-Oligodendrocytes-Traj-Heatmaps.pdf", 
        ArchRProj = projMulti4, 
        addDOC = FALSE, width = 6, height = 8)
rm(p1, p2, p3, p4)
```


### Integrative pseudo-time analyses

perform integrative analyses, such as identification of positive TF regulators by integration of gene scores / gene expression with motif accessibility across pseudo-time. 

```{r}
#| message: false
#| warning: false

#find motifs whose accessibility across pseudo-time is correlated with the Gene Expression of the TF gene
#trajectory at our disposal: trajGSM (GeneScoreMatrix/Expression), trajMM (MotifMatrix), trajGIM (GeneIntegrationMatrix),trajPM (PeakMatrix)
corGSM_MM <- correlateTrajectories(trajGSM, trajMM, corCutOff = 0.1)
```


```{r}
#| message: false
#| warning: false

corGSM_MM[[1]]
```


```{r}
#subset our corresponding trajectory SummarizedExperiment objects to only contain the elements that passed significance above
trajGSM2 <- trajGSM[corGSM_MM[[1]]$name1, ]
trajMM2 <- trajMM[corGSM_MM[[1]]$name2, ]
```


To best order these features, we can create a new trajectory where the values of these two trajectories are multiplied. This will allow us to create side-by-side heatmaps that are identically ordered by row.

```{r}
trajCombined <- trajGSM2
assay(trajCombined, withDimnames=FALSE) <- t(apply(assay(trajGSM2), 1, scale)) + t(apply(assay(trajMM2), 1, scale))
```


```{r}
#| message: false
#| warning: false

#extract the optimal row order from the return of the plotTrajectoryHeatmap() function
combinedMat <- plotTrajectoryHeatmap(seTrajectory = trajCombined, returnMatrix = TRUE, varCutOff = 0)
#or used row "trajCombined"
```


```{r}
#rowOrder <- match(rownames(combinedMat), rownames(trajGSM2))
rowOrder <- match(rownames(trajCombined), rownames(trajGSM2))
```


we are now ready to create our **paired heatmaps**. First, we will create the heatmap for the gene score trajectory. We specify the desired row order via the rowOrder parameter

```{r}
#| message: false
#| warning: false

#heatmap for Gene Expression Trajectory
ht1 <- plotTrajectoryHeatmap(trajGSM2,  
                             pal = paletteContinuous(set = "horizonExtra"),  
                             varCutOff = 0, 
                             rowOrder = rowOrder,
                             force = T)
```


```{r}
#| message: false
#| warning: false

#heatmap for the motif Trajectory
ht2 <- plotTrajectoryHeatmap(trajMM2, 
                             pal = paletteContinuous(set = "solarExtra"), 
                             varCutOff = 0, 
                             rowOrder = rowOrder)
```


```{r}
#Plotting these two heatmaps side-by-side, we see that the rows are matched across the two heatmaps.
p <- ht1 + ht2
```


```{r}
plotPDF(p,name = "trajectory-heatmap",ArchRProj = projMulti4, addDOC = F)
rm(p)
```


###########################################
###########################################
###########################################
###########################################
###########################################
###########################################


Lastly, we will save this project for future reference.

```{r}
projMulti4 <- saveArchRProject(ArchRProj = projMulti4, outputDirectory = "Save-ProjMulti4", overwrite = TRUE, load = TRUE)
```


###########################################
###########################################
###########################################
###########################################
###########################################
###########################################











